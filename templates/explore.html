{% extends "base.html" %}
{% block title %}Find Trails — Trail Condish{% endblock %}
{% block content %}
<section class="explore-header">
    <div class="container">
        <h1>Find Trails</h1>
        <div class="search-bar">
            <div class="search-input-wrap">
                <input type="text" id="searchInput" placeholder="Search trails or areas..." autocomplete="off">
                <div id="autocompleteDropdown" class="ac-dropdown"></div>
            </div>
            <select id="stateFilter">
                <option value="">All States</option>
            </select>
            <button id="nearMeBtn" class="btn btn-secondary" title="Near Me">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 2a10 10 0 0110 10 10 10 0 01-10 10A10 10 0 012 12 10 10 0 0112 2z" opacity=".3"/><path d="M12 8v0m0 8v0m-4-4h0m8 0h0"/></svg>
                Near Me
            </button>
            <button id="searchBtn" class="btn btn-primary">Search</button>
        </div>
    </div>
</section>
<section class="explore-body">
    <div class="container">
        <div id="viewToggle" class="view-toggle" style="display:none;">
            <button id="toggleMap" class="toggle-btn active">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"/><line x1="8" y1="2" x2="8" y2="18"/><line x1="16" y1="6" x2="16" y2="22"/></svg>
                Map
            </button>
            <button id="toggleList" class="toggle-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
                List
            </button>
            <span id="resultCount" class="result-count"></span>
        </div>
        <div id="mapOverlayControls" class="map-overlay-controls">
            <label class="map-toggle">
                <select id="basemapSelect" class="basemap-select">
                    <option value="carto">Standard</option>
                    <option value="topo">Topographic</option>
                    <option value="satellite">Satellite</option>
                    <option value="terrain">Terrain</option>
                </select>
            </label>
            <label class="map-toggle"><input type="checkbox" id="conditionsOverlayToggle"> Projected Trail Conditions</label>
            <label class="map-toggle"><input type="checkbox" id="trailOverlayToggle"> Trail Routes</label>
            <div id="conditionsLegend" class="conditions-legend" style="display:none;">
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(45,106,79,0.3)"></span>Dry</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(176,137,104,0.5)"></span>Wet</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(127,85,57,0.6)"></span>Muddy</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(74,144,217,0.6)"></span>Snowy</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(196,69,54,0.6)"></span>Icy</span>
            </div>
        </div>
        <div id="mapView" class="map-view">
            <div id="map" class="explore-map-full"></div>
            <button id="searchMapBtn" class="btn-search-map" style="display:none;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="7"/><path d="M21 21l-4.35-4.35"/></svg>
                Search This Area
            </button>
        </div>
        <div id="listView" class="list-view" style="display:none;">
            <div id="resultsList" class="results-list"></div>
        </div>
    </div>
</section>
{% endblock %}
{% block scripts %}
<script>
const US_STATES = {"AL":"Alabama","AK":"Alaska","AZ":"Arizona","AR":"Arkansas","CA":"California","CO":"Colorado","CT":"Connecticut","DE":"Delaware","FL":"Florida","GA":"Georgia","HI":"Hawaii","ID":"Idaho","IL":"Illinois","IN":"Indiana","IA":"Iowa","KS":"Kansas","KY":"Kentucky","LA":"Louisiana","ME":"Maine","MD":"Maryland","MA":"Massachusetts","MI":"Michigan","MN":"Minnesota","MS":"Mississippi","MO":"Missouri","MT":"Montana","NE":"Nebraska","NV":"Nevada","NH":"New Hampshire","NJ":"New Jersey","NM":"New Mexico","NY":"New York","NC":"North Carolina","ND":"North Dakota","OH":"Ohio","OK":"Oklahoma","OR":"Oregon","PA":"Pennsylvania","RI":"Rhode Island","SC":"South Carolina","SD":"South Dakota","TN":"Tennessee","TX":"Texas","UT":"Utah","VT":"Vermont","VA":"Virginia","WA":"Washington","WV":"West Virginia","WI":"Wisconsin","WY":"Wyoming"};
const sel = document.getElementById('stateFilter');
Object.keys(US_STATES).sort().forEach(s => { const o = document.createElement('option'); o.value = s; o.textContent = s; sel.appendChild(o); });

let map, markerCluster, routeLayers = [];
let currentView = 'map'; // default to map
let currentTrails = [];

const BASEMAPS = {
    carto: {url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', attr: '&copy; OSM &copy; CARTO', subdomains: 'abcd', maxZoom: 20},
    topo: {url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attr: '&copy; OSM &copy; OpenTopoMap', subdomains: 'abc', maxZoom: 17},
    satellite: {url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', attr: '&copy; Esri', maxZoom: 19},
    terrain: {url: 'https://{s}.tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey=6170aad10dfd42a38d4d8c709a536f38', attr: '&copy; Thunderforest &copy; OSM', subdomains: 'abc', maxZoom: 22},
};
let currentBasemap = null;

function setBasemap(key) {
    const cfg = BASEMAPS[key] || BASEMAPS.carto;
    if (currentBasemap) map.removeLayer(currentBasemap);
    currentBasemap = L.tileLayer(cfg.url, {attribution: cfg.attr, subdomains: cfg.subdomains || '', maxZoom: cfg.maxZoom || 20});
    currentBasemap.addTo(map);
    localStorage.setItem('tc_basemap', key);
}

function initMap() {
    if (map) return;
    map = L.map('map').setView([39.5, -98.5], 4);
    const saved = localStorage.getItem('tc_basemap') || 'carto';
    document.getElementById('basemapSelect').value = saved;
    setBasemap(saved);
    markerCluster = L.markerClusterGroup({
        maxClusterRadius: 50,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        iconCreateFunction: function(cluster) {
            const count = cluster.getChildCount();
            let size = 'small';
            if (count >= 50) size = 'large';
            else if (count >= 10) size = 'medium';
            return L.divIcon({
                html: '<div><span>' + count + '</span></div>',
                className: 'trail-cluster trail-cluster-' + size,
                iconSize: L.point(40, 40)
            });
        }
    });
    map.addLayer(markerCluster);
    map.on('zoomend', onZoomChange);
    
    // Overlays
    const trailsOverlay = L.tileLayer('https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png', {opacity: 0.6, attribution:'Waymarked Trails'});
    let conditionsActive = false;
    let conditionsCache = {};
    let conditionsLoading = false;
    let canvasOverlay = null;
    let lastGrid = null;
    let lastGridBounds = null;
    
    // Condition severity for interpolation (0=dry, 1=wet, 2=muddy, 3=snowy, 4=icy)
    const COND_SCORE = {clear: 0, dry: 0, wet: 1, muddy: 2, snowy: 3, icy: 4};
    const COND_RGB = {
        0: [82, 183, 136],   // dry/clear - green
        1: [176, 137, 104],  // wet - tan
        2: [127, 85, 57],    // muddy - brown
        3: [74, 144, 217],   // snowy - blue
        4: [196, 69, 54],    // icy - red
    };
    
    function lerpColor(score) {
        const lo = Math.floor(Math.max(0, Math.min(3, score)));
        const hi = Math.min(4, lo + 1);
        const t = score - lo;
        const a = COND_RGB[lo], b = COND_RGB[hi];
        return [
            Math.round(a[0] + (b[0] - a[0]) * t),
            Math.round(a[1] + (b[1] - a[1]) * t),
            Math.round(a[2] + (b[2] - a[2]) * t),
        ];
    }
    
    async function loadConditionsGrid() {
        if (!conditionsActive || conditionsLoading) return;
        const zoom = map.getZoom();
        if (zoom < 5) {
            if (canvasOverlay) map.removeLayer(canvasOverlay);
            return;
        }
        
        conditionsLoading = true;
        const bounds = map.getBounds();
        const s = bounds.getSouth(), n = bounds.getNorth();
        const w = bounds.getWest(), e = bounds.getEast();
        // Pad bounds slightly for smoother edges
        const latPad = (n - s) * 0.1, lonPad = (e - w) * 0.1;
        const ps = s - latPad, pn = n + latPad, pw = w - lonPad, pe = e + lonPad;
        
        // Denser grid: more sample points
        const gridCols = Math.min(10, Math.max(4, zoom - 2));
        const gridRows = Math.min(8, Math.max(3, zoom - 3));
        const latStep = (pn - ps) / (gridRows - 1);
        const lonStep = (pe - pw) / (gridCols - 1);
        
        // Build grid of sample points
        const grid = [];
        for (let r = 0; r < gridRows; r++) {
            grid[r] = [];
            for (let c = 0; c < gridCols; c++) {
                const lat = ps + latStep * r;
                const lon = pw + lonStep * c;
                const key = `${lat.toFixed(2)},${lon.toFixed(2)}`;
                grid[r][c] = {lat, lon, key, score: 0, reasons: []};
            }
        }
        
        // Fetch weather for uncached points via batch endpoint
        const allPts = grid.flat();
        const uncached = allPts.filter(p => !conditionsCache[p.key]);
        if (uncached.length > 0) {
            try {
                const lats = uncached.map(p => p.lat.toFixed(4)).join(',');
                const lons = uncached.map(p => p.lon.toFixed(4)).join(',');
                const res = await fetch(`/api/weather/grid?lats=${lats}&lons=${lons}`);
                const data = await res.json();
                if (Array.isArray(data)) {
                    for (let i = 0; i < uncached.length; i++) {
                        conditionsCache[uncached[i].key] = data[i] || {condition: 'clear', reasons: []};
                    }
                }
            } catch(e) {
                for (const p of uncached) conditionsCache[p.key] = {condition: 'clear', reasons: []};
            }
        }
        
        // Assign scores from cache
        for (let r = 0; r < gridRows; r++) {
            for (let c = 0; c < gridCols; c++) {
                const inf = conditionsCache[grid[r][c].key] || {condition: 'clear'};
                grid[r][c].score = COND_SCORE[inf.condition] ?? 0;
                grid[r][c].reasons = inf.reasons || [];
            }
        }
        
        // Render interpolated canvas
        const canvasW = 300, canvasH = 200;
        const canvas = document.createElement('canvas');
        canvas.width = canvasW;
        canvas.height = canvasH;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(canvasW, canvasH);
        
        for (let py = 0; py < canvasH; py++) {
            for (let px = 0; px < canvasW; px++) {
                // Map pixel to grid position (float)
                const gr = (py / canvasH) * (gridRows - 1);
                const gc = (px / canvasW) * (gridCols - 1);
                
                // Bilinear interpolation
                const r0 = Math.floor(gr), r1 = Math.min(gridRows - 1, r0 + 1);
                const c0 = Math.floor(gc), c1 = Math.min(gridCols - 1, c0 + 1);
                const tr = gr - r0, tc = gc - c0;
                
                const s00 = grid[r0][c0].score;
                const s01 = grid[r0][c1].score;
                const s10 = grid[r1][c0].score;
                const s11 = grid[r1][c1].score;
                const score = s00 * (1 - tr) * (1 - tc) + s01 * (1 - tr) * tc + s10 * tr * (1 - tc) + s11 * tr * tc;
                
                const rgb = lerpColor(score);
                const idx = (py * canvasW + px) * 4;
                // Flip vertically (canvas y=0 is top, but lat increases upward)
                const fpy = canvasH - 1 - py;
                const fidx = (fpy * canvasW + px) * 4;
                imgData.data[fidx] = rgb[0];
                imgData.data[fidx + 1] = rgb[1];
                imgData.data[fidx + 2] = rgb[2];
                imgData.data[fidx + 3] = 90; // transparency
            }
        }
        ctx.putImageData(imgData, 0, 0);
        
        // Apply gaussian-like blur for smoother look
        ctx.filter = 'blur(8px)';
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';
        
        // Remove old overlay
        if (canvasOverlay) map.removeLayer(canvasOverlay);
        
        // Add as image overlay
        const imgUrl = canvas.toDataURL();
        canvasOverlay = L.imageOverlay(imgUrl, [[ps, pw], [pn, pe]], {opacity: 0.55, interactive: false});
        canvasOverlay.addTo(map);
        
        lastGrid = grid;
        lastGridBounds = {s: ps, n: pn, w: pw, e: pe, rows: gridRows, cols: gridCols};
        conditionsLoading = false;
    }
    
    document.getElementById('conditionsOverlayToggle').addEventListener('change', function() {
        conditionsActive = this.checked;
        document.getElementById('conditionsLegend').style.display = this.checked ? 'flex' : 'none';
        if (this.checked) {
            loadConditionsGrid();
        } else {
            if (canvasOverlay) map.removeLayer(canvasOverlay);
        }
    });
    
    map.on('moveend', function() {
        if (conditionsActive) loadConditionsGrid();
    });
    
    // Click on map to see conditions at that point
    map.on('click', function(e) {
        if (!conditionsActive || !lastGrid || !lastGridBounds) return;
        const gb = lastGridBounds;
        const lat = e.latlng.lat, lon = e.latlng.lng;
        if (lat < gb.s || lat > gb.n || lon < gb.w || lon > gb.e) return;
        
        // Find nearest grid cell
        const gr = ((lat - gb.s) / (gb.n - gb.s)) * (gb.rows - 1);
        const gc = ((lon - gb.w) / (gb.e - gb.w)) * (gb.cols - 1);
        const r = Math.round(Math.max(0, Math.min(gb.rows - 1, gr)));
        const c = Math.round(Math.max(0, Math.min(gb.cols - 1, gc)));
        const cell = lastGrid[r] && lastGrid[r][c];
        if (!cell) return;
        const inf = conditionsCache[cell.key];
        if (!inf) return;
        
        const label = (inf.condition || 'clear').charAt(0).toUpperCase() + (inf.condition || 'clear').slice(1);
        const reasons = (inf.reasons || []).join('<br>');
        L.popup()
            .setLatLng(e.latlng)
            .setContent(`<strong style="font-size:1.1em">${label}</strong><br><small style="color:#555">${reasons}</small>`)
            .openOn(map);
    });
    
    document.getElementById('trailOverlayToggle').addEventListener('change', function() {
        if (this.checked) trailsOverlay.addTo(map);
        else if (map.hasLayer(trailsOverlay)) map.removeLayer(trailsOverlay);
    });
    
    document.getElementById('basemapSelect').addEventListener('change', function() {
        setBasemap(this.value);
    });
}

function clearMarkers() {
    if (markerCluster) markerCluster.clearLayers();
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
}

function onZoomChange() {
    const zoom = map.getZoom();
    routeLayers.forEach(l => {
        if (zoom >= 12) { if (!map.hasLayer(l)) map.addLayer(l); }
        else { if (map.hasLayer(l)) map.removeLayer(l); }
    });
}

function difficultyLabel(sac) {
    const m = {'hiking':'Easy','mountain_hiking':'Moderate','demanding_mountain_hiking':'Hard','alpine_hiking':'Expert','demanding_alpine_hiking':'Expert+','difficult_alpine_hiking':'Extreme'};
    return m[sac] || '';
}

function showView(view) {
    currentView = view;
    document.getElementById('mapView').style.display = view === 'map' ? 'block' : 'none';
    document.getElementById('mapOverlayControls').style.display = view === 'map' ? 'flex' : 'none';
    document.getElementById('listView').style.display = view === 'list' ? 'block' : 'none';
    document.getElementById('toggleMap').classList.toggle('active', view === 'map');
    document.getElementById('toggleList').classList.toggle('active', view === 'list');
    if (view === 'map' && map) setTimeout(() => map.invalidateSize(), 50);
}

document.getElementById('toggleMap').addEventListener('click', () => showView('map'));
document.getElementById('toggleList').addEventListener('click', () => showView('list'));

// --- Autocomplete ---
let acTimer = null;
const searchInput = document.getElementById('searchInput');
const acDropdown = document.getElementById('autocompleteDropdown');

searchInput.addEventListener('input', () => {
    clearTimeout(acTimer);
    const q = searchInput.value.trim();
    if (q.length < 2) { acDropdown.style.display = 'none'; return; }
    acTimer = setTimeout(() => fetchAutocomplete(q), 150);
});

searchInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') { acDropdown.style.display = 'none'; doSearch(); }
    if (e.key === 'Escape') acDropdown.style.display = 'none';
});

document.addEventListener('click', e => {
    if (!e.target.closest('.search-input-wrap')) acDropdown.style.display = 'none';
});

async function fetchAutocomplete(q) {
    try {
        const res = await fetch('/api/autocomplete?q=' + encodeURIComponent(q));
        const items = await res.json();
        if (!items.length) { acDropdown.style.display = 'none'; return; }
        
        acDropdown.innerHTML = items.map(item => {
            const icon = item.type === 'trail'
                ? '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 17l4-8 4 6 4-10 6 12"/></svg>'
                : '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0118 0z"/><circle cx="12" cy="10" r="3"/></svg>';
            const label = item.type === 'trail' ? 'Trail' : 'Area';
            return `<div class="ac-item" data-type="${item.type}" data-osm-type="${item.osm_type || ''}" data-osm-id="${item.osm_id || ''}" data-name="${item.name}" data-lat="${item.lat || ''}" data-lon="${item.lon || ''}">
                <span class="ac-icon">${icon}</span>
                <div class="ac-text">
                    <span class="ac-name">${item.name}</span>
                    ${item.context ? `<span class="ac-context">${item.context}</span>` : ''}
                </div>
                <span class="ac-label ac-label-${item.type}">${label}</span>
            </div>`;
        }).join('');
        acDropdown.style.display = 'block';
        
        acDropdown.querySelectorAll('.ac-item').forEach(el => {
            el.addEventListener('click', () => {
                acDropdown.style.display = 'none';
                const osmType = el.dataset.osmType;
                const osmId = el.dataset.osmId;
                if (el.dataset.type === 'trail' && (osmType === 'way' || osmType === 'relation') && osmId) {
                    window.location = `/trail/${osmType}/${osmId}`;
                } else {
                    // Area or unresolvable trail — search using the name
                    searchInput.value = el.dataset.name;
                    doSearch();
                }
            });
        });
    } catch(e) {
        acDropdown.style.display = 'none';
    }
}

// --- Search ---
async function doSearch() {
    const q = document.getElementById('searchInput').value;
    const state = document.getElementById('stateFilter').value;
    const params = new URLSearchParams();
    if (q) params.set('q', q);
    if (state) params.set('state', state);
    
    document.getElementById('resultsList').innerHTML = '';
    showView('map');
    
    // Show loading in list view
    document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Searching trails via OpenStreetMap...</p></div>';
    
    try {
        const res = await fetch('/api/search?' + params);
        const trails = await res.json();
        if (trails.error) {
            document.getElementById('resultsList').innerHTML = `<p class="muted">Error: ${trails.error}</p>`;
            return;
        }
        if (!trails.length) {
            document.getElementById('resultsList').innerHTML = '<p class="muted">No trails found</p>';
            document.getElementById('resultCount').textContent = '0 trails found';
            return;
        }
        
        currentTrails = trails;
        sessionStorage.setItem('trailcondish_results', JSON.stringify(trails));
        renderResults(trails);
    } catch(e) {
        document.getElementById('resultsList').innerHTML = `<p class="muted">Search failed: ${e.message}</p>`;
    }
}

function renderResults(trails, skipFitBounds) {
    clearMarkers();
    const bounds = [];
    
    document.getElementById('resultCount').textContent = `${trails.length} trail${trails.length !== 1 ? 's' : ''} found`;
    
    // Build list HTML
    let html = '';
    trails.forEach(t => {
        const diff = difficultyLabel(t.difficulty);
        const trailUrl = `/trail/${t.osm_type}/${t.osm_id}`;
        
        html += `<div class="trail-card" onclick="window.location='${trailUrl}'">
            <h3 class="tc-name">${t.name}</h3>
            <div class="tc-tags">
                ${diff ? `<span class="tag tag-diff">${diff}</span>` : ''}
                ${t.surface ? `<span class="tag">${t.surface}</span>` : ''}
                ${t.distance ? `<span class="tag">${t.distance}</span>` : ''}
                <span class="tag tag-type">${t.osm_type}</span>
            </div>
            ${t.desc ? `<p class="tc-desc">${t.desc}</p>` : ''}
            <a href="${trailUrl}" class="tc-link">View Trail →</a>
        </div>`;
        
        if (t.lat && t.lon) {
            const m = L.marker([t.lat, t.lon])
                .bindPopup(`<b>${t.name}</b><br>${diff ? diff + '<br>' : ''}<a href="${trailUrl}">View Trail</a>`);
            markerCluster.addLayer(m);
            bounds.push([t.lat, t.lon]);
        }
    });
    
    document.getElementById('resultsList').innerHTML = html;
    if (bounds.length && !skipFitBounds) map.fitBounds(bounds, {padding: [30, 30]});
    
    // Route loading disabled to avoid Overpass rate limits
    // Routes are visible on the Waymarked Trails overlay instead
}

async function loadRoutes(trails) {
    // Load geometry for first 30 trails for route display
    const toLoad = trails.filter(t => t.lat && t.lon).slice(0, 30);
    for (const t of toLoad) {
        try {
            const res = await fetch(`/api/trail/${t.osm_type}/${t.osm_id}`);
            const data = await res.json();
            if (data.geometry && data.geometry.length > 1) {
                const latlngs = data.geometry.map(p => [p.lat, p.lon]);
                const line = L.polyline(latlngs, {color: '#2d6a4f', weight: 3, opacity: 0.7});
                routeLayers.push(line);
                // Only show if zoomed in enough
                if (map.getZoom() >= 12) line.addTo(map);
            }
        } catch(e) {}
    }
}

// Init map on page load
initMap();
document.getElementById('viewToggle').style.display = 'flex';

// Save map state on move
map.on('moveend', () => {
    const c = map.getCenter();
    sessionStorage.setItem('trailcondish_map', JSON.stringify({lat: c.lat, lng: c.lng, zoom: map.getZoom()}));
});

// Restore search results first (without fitting bounds)
const savedResults = sessionStorage.getItem('trailcondish_results');
if (savedResults) {
    try {
        const trails = JSON.parse(savedResults);
        if (trails.length) {
            currentTrails = trails;
            renderResults(trails, true); // skip fitBounds
        }
    } catch(e) {}
}

// Then restore map position (takes priority over fitBounds)
const savedMap = sessionStorage.getItem('trailcondish_map');
if (savedMap) {
    try {
        const s = JSON.parse(savedMap);
        map.setView([s.lat, s.lng], s.zoom);
    } catch(e) {}
}

// Show "Search This Area" button when user pans/zooms the map
const searchMapBtn = document.getElementById('searchMapBtn');
let userMoved = false;
map.on('moveend', () => {
    if (map.getZoom() >= 9) {
        searchMapBtn.style.display = 'flex';
    } else {
        searchMapBtn.style.display = 'none';
    }
});

searchMapBtn.addEventListener('click', async () => {
    const bounds = map.getBounds();
    const bbox = `${bounds.getSouth().toFixed(5)},${bounds.getWest().toFixed(5)},${bounds.getNorth().toFixed(5)},${bounds.getEast().toFixed(5)}`;
    searchMapBtn.style.display = 'none';
    document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Searching this area...</p></div>';
    
    try {
        const res = await fetch(`/api/search?bbox=${encodeURIComponent(bbox)}`);
        const trails = await res.json();
        if (!trails.length) {
            document.getElementById('resultsList').innerHTML = '<p class="muted">No trails found in this area. Try zooming out.</p>';
            document.getElementById('resultCount').textContent = '0 trails found';
            return;
        }
        currentTrails = trails;
        // Render without fitting bounds (keep current view)
        clearMarkers();
        document.getElementById('resultCount').textContent = `${trails.length} trail${trails.length !== 1 ? 's' : ''} found`;
        let html = '';
        trails.forEach(t => {
            const diff = difficultyLabel(t.difficulty);
            const trailUrl = `/trail/${t.osm_type}/${t.osm_id}`;
            html += `<div class="trail-card" onclick="window.location='${trailUrl}'">
                <h3 class="tc-name">${t.name}</h3>
                <div class="tc-tags">
                    ${diff ? `<span class="tag tag-diff">${diff}</span>` : ''}
                    ${t.surface ? `<span class="tag">${t.surface}</span>` : ''}
                    ${t.distance ? `<span class="tag">${t.distance}</span>` : ''}
                </div>
                <a href="${trailUrl}" class="tc-link">View Trail</a>
            </div>`;
            if (t.lat && t.lon) {
                const m = L.marker([t.lat, t.lon])
                    .bindPopup(`<b>${t.name}</b><br>${diff ? diff + '<br>' : ''}<a href="${trailUrl}">View Trail</a>`);
                markerCluster.addLayer(m);
            }
        });
        document.getElementById('resultsList').innerHTML = html;
    } catch(e) {
        document.getElementById('resultsList').innerHTML = `<p class="muted">Error: ${e.message}</p>`;
    }
});

document.getElementById('searchBtn').addEventListener('click', doSearch);

document.getElementById('nearMeBtn').addEventListener('click', () => {
    if (!navigator.geolocation) return alert('Geolocation not supported');
    document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Getting your location...</p></div>';
    showView('map');
    
    navigator.geolocation.getCurrentPosition(async pos => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        searchInput.value = `Near ${lat.toFixed(2)}, ${lon.toFixed(2)}`;
        document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Searching nearby trails...</p></div>';
        
        try {
            const res = await fetch(`/api/search?lat=${lat}&lon=${lon}`);
            const trails = await res.json();
            if (!trails.length) {
                document.getElementById('resultsList').innerHTML = '<p class="muted">No trails found nearby</p>';
                document.getElementById('resultCount').textContent = '0 trails found';
                return;
            }
            currentTrails = trails;
            renderResults(trails);
        } catch(e) {
            document.getElementById('resultsList').innerHTML = `<p class="muted">Error: ${e.message}</p>`;
        }
    }, () => alert('Could not get location'));
});
</script>
{% endblock %}
