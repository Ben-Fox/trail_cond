{% extends "base.html" %}
{% block title %}Find Trails — Trail Condish{% endblock %}
{% block content %}
<section class="explore-header">
    <div class="container">
        <h1>Find Trails</h1>
        <div class="search-bar">
            <div class="search-input-wrap">
                <input type="text" id="searchInput" placeholder="Search trails or areas..." autocomplete="off">
                <div id="autocompleteDropdown" class="ac-dropdown"></div>
            </div>
            <select id="stateFilter">
                <option value="">All States</option>
            </select>
            <button id="nearMeBtn" class="btn btn-secondary" title="Near Me">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 2a10 10 0 0110 10 10 10 0 01-10 10A10 10 0 012 12 10 10 0 0112 2z" opacity=".3"/><path d="M12 8v0m0 8v0m-4-4h0m8 0h0"/></svg>
                Near Me
            </button>
            <button id="searchBtn" class="btn btn-primary">Search</button>
        </div>
        <div class="trail-filters">
            <span class="filter-label">Trail Type:</span>
            <button class="filter-chip active" data-filter="all">All</button>
            <button class="filter-chip" data-filter="hiking">Hiking</button>
            <button class="filter-chip" data-filter="biking">Biking</button>
            <button class="filter-chip" data-filter="paved">Paved / Path</button>
            <button class="filter-chip" data-filter="horse">Horseback</button>
        </div>
    </div>
</section>
<section class="explore-body">
    <div class="container">
        <div id="viewToggle" class="view-toggle" style="display:none;">
            <button id="toggleMap" class="toggle-btn active">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"/><line x1="8" y1="2" x2="8" y2="18"/><line x1="16" y1="6" x2="16" y2="22"/></svg>
                Map
            </button>
            <button id="toggleList" class="toggle-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
                List
            </button>
            <span id="resultCount" class="result-count"></span>
        </div>
        <div id="mapOverlayControls" class="map-overlay-controls">
            <label class="map-toggle">
                <select id="basemapSelect" class="basemap-select">
                    <option value="carto">Standard</option>
                    <option value="topo">Topographic</option>
                    <option value="satellite">Satellite</option>
                    <option value="terrain">Terrain</option>
                </select>
            </label>
            <label class="map-toggle"><input type="checkbox" id="conditionsOverlayToggle"> Projected Trail Conditions</label>
            <label class="map-toggle"><input type="checkbox" id="trailOverlayToggle"> Trail Routes</label>
            <label class="map-toggle"><input type="checkbox" id="aqOverlayToggle"> Air Quality</label>
            <div id="conditionsLegend" class="conditions-legend" style="display:none;">
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(45,106,79,0.3)"></span>Dry</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(176,137,104,0.5)"></span>Wet</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(127,85,57,0.6)"></span>Muddy</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(74,144,217,0.6)"></span>Snowy</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(196,69,54,0.6)"></span>Icy</span>
            </div>
            <div id="aqLegend" class="conditions-legend" style="display:none;">
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(0,228,0,0.6)"></span>Good</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(255,255,0,0.6)"></span>Moderate</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(255,126,0,0.7)"></span>USG</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(255,0,0,0.7)"></span>Unhealthy</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(143,63,151,0.7)"></span>Very Unhealthy</span>
            </div>
        </div>
        <div id="mapView" class="map-view">
            <div id="map" class="explore-map-full"></div>
            <button id="searchMapBtn" class="btn-search-map" style="display:none;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="7"/><path d="M21 21l-4.35-4.35"/></svg>
                Search This Area
            </button>
        </div>
        <div id="listView" class="list-view" style="display:none;">
            <div id="resultsList" class="results-list"></div>
        </div>
    </div>
</section>
{% endblock %}
{% block scripts %}
<script>
const US_STATES = {"AL":"Alabama","AK":"Alaska","AZ":"Arizona","AR":"Arkansas","CA":"California","CO":"Colorado","CT":"Connecticut","DE":"Delaware","FL":"Florida","GA":"Georgia","HI":"Hawaii","ID":"Idaho","IL":"Illinois","IN":"Indiana","IA":"Iowa","KS":"Kansas","KY":"Kentucky","LA":"Louisiana","ME":"Maine","MD":"Maryland","MA":"Massachusetts","MI":"Michigan","MN":"Minnesota","MS":"Mississippi","MO":"Missouri","MT":"Montana","NE":"Nebraska","NV":"Nevada","NH":"New Hampshire","NJ":"New Jersey","NM":"New Mexico","NY":"New York","NC":"North Carolina","ND":"North Dakota","OH":"Ohio","OK":"Oklahoma","OR":"Oregon","PA":"Pennsylvania","RI":"Rhode Island","SC":"South Carolina","SD":"South Dakota","TN":"Tennessee","TX":"Texas","UT":"Utah","VT":"Vermont","VA":"Virginia","WA":"Washington","WV":"West Virginia","WI":"Wisconsin","WY":"Wyoming"};
const sel = document.getElementById('stateFilter');
Object.keys(US_STATES).sort().forEach(s => { const o = document.createElement('option'); o.value = s; o.textContent = s; sel.appendChild(o); });

let map, markerCluster, routeLayers = [];
let currentView = 'map'; // default to map
let currentTrails = [];
let activeTrailType = 'all';
let programmaticMove = false; // distinguish user pans from flyTo/fitBounds

// Condition pin icons
const conditionCache = {}; // key: "lat,lon" -> {condition, reasons}
const markerMap = new Map(); // key: trail osm_type:osm_id -> L.marker

function getConditionIcon(condition) {
    const iconMap = {
        'clear': '/static/pins/cond-clear.svg',
        'dry': '/static/pins/cond-clear.svg',
        'wet': '/static/pins/cond-wet.svg',
        'muddy': '/static/pins/cond-muddy.svg',
        'snowy': '/static/pins/cond-snowy.svg',
        'icy': '/static/pins/cond-icy.svg',
        'closed': '/static/pins/cond-closed.svg',
    };
    return L.icon({
        iconUrl: iconMap[condition] || iconMap['clear'],
        iconSize: [40, 50],
        iconAnchor: [20, 50],
        popupAnchor: [0, -50],
    });
}

const defaultIcon = getConditionIcon('clear');

function condCacheKey(lat, lon) {
    // Consistent key: round to 3 decimal places (~111m precision)
    return `${parseFloat(lat).toFixed(3)},${parseFloat(lon).toFixed(3)}`;
}

async function updateMarkerConditions(trails) {
    const withCoords = trails.filter(t => t.lat && t.lon);
    if (!withCoords.length) return;
    
    // Filter out already-cached trails
    const toFetch = withCoords.filter(t => !conditionCache[condCacheKey(t.lat, t.lon)]);
    
    if (toFetch.length > 0) {
        // Batch in groups of 20 (Open-Meteo multi-location limit)
        for (let i = 0; i < toFetch.length; i += 20) {
            const batch = toFetch.slice(i, i + 20);
            const lats = batch.map(t => parseFloat(t.lat).toFixed(4)).join(',');
            const lons = batch.map(t => parseFloat(t.lon).toFixed(4)).join(',');
            try {
                const res = await fetch(`/api/weather/grid?lats=${lats}&lons=${lons}`);
                const data = await res.json();
                if (Array.isArray(data)) {
                    for (let j = 0; j < batch.length; j++) {
                        conditionCache[condCacheKey(batch[j].lat, batch[j].lon)] = data[j] || {condition: 'clear', reasons: []};
                    }
                }
            } catch(e) { /* keep default icons on error */ }
        }
    }
    
    // Update all marker icons + condition tags from cache
    let changed = false;
    for (const t of withCoords) {
        const cached = conditionCache[condCacheKey(t.lat, t.lon)];
        if (cached) {
            const mKey = `${t.osm_type}:${t.osm_id}`;
            const marker = markerMap.get(mKey);
            if (marker && marker._trailCondition !== cached.condition) {
                marker.setIcon(getConditionIcon(cached.condition));
                marker._trailCondition = cached.condition;
                // Update popup with condition info
                const condLabel = cached.condition.charAt(0).toUpperCase() + cached.condition.slice(1);
                const condColors = {clear:'#2d6a4f',dry:'#2d6a4f',wet:'#b08968',muddy:'#7f5539',snowy:'#4a90d9',icy:'#c44536'};
                const condColor = condColors[cached.condition] || '#2d6a4f';
                const reasons = (cached.reasons || []).slice(0, 2).join('<br>');
                let trailUrl = `/trail/${t.osm_type}/${t.osm_id}`;
                if (t.way_ids && t.way_ids.length > 1) trailUrl += `?way_ids=${t.way_ids.join(',')}`;
                const diff = difficultyLabel(t.difficulty);
                marker.setPopupContent(
                    `<b>${t.name}</b><br>` +
                    `<span style="color:${condColor};font-weight:700">${condLabel}</span><br>` +
                    `<small style="color:#666">${reasons}</small><br>` +
                    `${diff ? diff + '<br>' : ''}` +
                    `<a href="${trailUrl}">View Trail</a><br>` +
                    `<small style="color:#888">Click pin to show route</small>`
                );
                changed = true;
            }
        }
    }
    // Update condition pins in list view cards
    for (const t of withCoords) {
        const cached = conditionCache[condCacheKey(t.lat, t.lon)];
        if (cached) {
            const card = document.querySelector(`.trail-card[data-trail-id="${t.osm_type}:${t.osm_id}"] .tc-pin`);
            if (card) {
                const cond = cached.condition === 'dry' ? 'clear' : cached.condition;
                card.src = `/static/pins/cond-${cond}.svg`;
                card.alt = cached.condition;
            }
        }
    }
    
    // Rebuild clusters to pick up updated condition colors
    if (changed && markerCluster) {
        const allMarkers = [];
        markerMap.forEach(m => allMarkers.push(m));
        markerCluster.clearLayers();
        markerCluster.addLayers(allMarkers);
    }
}

// Trail type filter chips
document.querySelectorAll('.filter-chip').forEach(chip => {
    chip.addEventListener('click', function() {
        document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
        this.classList.add('active');
        activeTrailType = this.dataset.filter;
        // Re-search if we have results
        if (currentTrails.length > 0 || document.getElementById('searchInput').value.trim()) {
            doSearch();
        }
    });
});

const BASEMAPS = {
    carto: {url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', attr: '&copy; OSM &copy; CARTO', subdomains: 'abcd', maxZoom: 20},
    topo: {url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attr: '&copy; OSM &copy; OpenTopoMap', subdomains: 'abc', maxZoom: 17},
    satellite: {url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', attr: '&copy; Esri', maxZoom: 19},
    terrain: {url: 'https://{s}.tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey=6170aad10dfd42a38d4d8c709a536f38', attr: '&copy; Thunderforest &copy; OSM', subdomains: 'abc', maxZoom: 22},
};
let currentBasemap = null;

function setBasemap(key) {
    const cfg = BASEMAPS[key] || BASEMAPS.carto;
    if (currentBasemap) map.removeLayer(currentBasemap);
    currentBasemap = L.tileLayer(cfg.url, {attribution: cfg.attr, subdomains: cfg.subdomains || '', maxZoom: cfg.maxZoom || 20});
    currentBasemap.addTo(map);
    localStorage.setItem('tc_basemap', key);
}

function initMap() {
    if (map) return;
    map = L.map('map').setView([39.5, -98.5], 4);
    const saved = localStorage.getItem('tc_basemap') || 'carto';
    document.getElementById('basemapSelect').value = saved;
    setBasemap(saved);
    markerCluster = L.markerClusterGroup({
        maxClusterRadius: 50,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        chunkedLoading: true,
        iconCreateFunction: function(cluster) {
            const count = cluster.getChildCount();
            let size = count >= 50 ? 'large' : count >= 10 ? 'medium' : 'small';
            const dims = {small: [44, 54], medium: [52, 64], large: [60, 74]};
            const [w, h] = dims[size];
            const fs = {small: 13, medium: 15, large: 17}[size];
            
            // Determine dominant condition from child markers
            const condCounts = {};
            cluster.getAllChildMarkers().forEach(m => {
                const cond = m._trailCondition || 'clear';
                condCounts[cond] = (condCounts[cond] || 0) + 1;
            });
            let dominant = 'clear';
            let maxCount = 0;
            // Priority: icy > snowy > muddy > wet > clear/dry
            const priority = {icy: 50, snowy: 40, muddy: 30, wet: 20, clear: 0, dry: 0};
            for (const [cond, cnt] of Object.entries(condCounts)) {
                const score = cnt + (priority[cond] || 0) * 0.01;
                if (score > maxCount) { maxCount = score; dominant = cond; }
            }
            
            const colors = {
                clear: {pin: '#2d6a4f', inner: '#52b788'},
                dry: {pin: '#2d6a4f', inner: '#52b788'},
                wet: {pin: '#2d6a4f', inner: '#7b9ec4'},
                muddy: {pin: '#7f5539', inner: '#b08968'},
                snowy: {pin: '#4a90d9', inner: '#7bb8e8'},
                icy: {pin: '#c44536', inner: '#e07060'},
                closed: {pin: '#555', inner: '#888'},
            };
            const c = colors[dominant] || colors.clear;
            
            // SVG pin shape with count
            const svg = `<svg width="${w}" height="${h}" viewBox="0 0 44 54" xmlns="http://www.w3.org/2000/svg">
              <path d="M22,2 C33,2 42,11 42,22 C42,33 22,52 22,52 C22,52 2,33 2,22 C2,11 11,2 22,2Z" fill="${c.pin}" stroke="#f5f0e8" stroke-width="2"/>
              <circle cx="22" cy="20" r="13" fill="${c.inner}"/>
              <text x="22" y="25" text-anchor="middle" font-family="Nunito,sans-serif" font-weight="800" font-size="${fs}" fill="#fff">${count}</text>
            </svg>`;
            
            return L.divIcon({
                html: svg,
                className: 'cluster-pin',
                iconSize: L.point(w, h),
                iconAnchor: L.point(w/2, h),
            });
        }
    });
    map.addLayer(markerCluster);
    map.on('zoomend', onZoomChange);
    
    // Overlays
    const trailsOverlay = L.tileLayer('https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png', {opacity: 0.6, attribution:'Waymarked Trails'});
    // === Conditions Overlay — Server-rendered tile layer (like real weather maps) ===
    // Tiles are generated server-side, cached 30min, served as standard {z}/{x}/{y}.png
    // This is how OpenWeatherMap, RainViewer, and every real weather map works.
    // Benefits: perfectly stable across zoom/pan, no client-side computation, 
    // consistent colors at every zoom level, cached by browser + CDN.
    let conditionsActive = false;
    let conditionsTileLayer = null;
    const COND_LABELS = {clear:'Clear/Dry', dry:'Dry', wet:'Wet', muddy:'Muddy', snowy:'Snowy', icy:'Icy'};
    
    document.getElementById('conditionsOverlayToggle').addEventListener('change', function() {
        conditionsActive = this.checked;
        document.getElementById('conditionsLegend').style.display = this.checked ? 'flex' : 'none';
        if (this.checked) {
            if (!conditionsTileLayer) {
                conditionsTileLayer = L.tileLayer('/api/tiles/conditions/{z}/{x}/{y}.png', {
                    opacity: 0.6,
                    maxZoom: 14,
                    minZoom: 5,
                    attribution: 'Conditions: Open-Meteo',
                    errorTileUrl: '', // suppress broken tile images
                });
            }
            conditionsTileLayer.addTo(map);
        } else {
            if (conditionsTileLayer && map.hasLayer(conditionsTileLayer)) {
                map.removeLayer(conditionsTileLayer);
            }
        }
    });
    
    // Click to inspect conditions at a point (fetches weather for that point)
    map.on('click', async function(e) {
        if (!conditionsActive) return;
        const lat = e.latlng.lat.toFixed(2), lon = e.latlng.lng.toFixed(2);
        try {
            const res = await fetch(`/api/weather/history?lat=${lat}&lon=${lon}`);
            const w = await res.json();
            if (w.error) return;
            const inf = w.inference;
            const label = COND_LABELS[inf.condition] || inf.condition || 'Clear';
            const reasons = (inf.reasons || []).join('<br>');
            L.popup()
                .setLatLng(e.latlng)
                .setContent(`<strong style="font-size:1.1em">${label}</strong><br><small style="color:#555">${reasons}</small>`)
                .openOn(map);
        } catch(err) {}
    });
    
    // === Air Quality Overlay — same tile approach as conditions ===
    let aqActive = false;
    let aqTileLayer = null;
    const AQ_LABELS = {0:'Good',51:'Moderate',101:'Unhealthy for Sensitive Groups',151:'Unhealthy',201:'Very Unhealthy',301:'Hazardous'};
    
    function aqLabel(aqi) {
        if (aqi <= 50) return 'Good';
        if (aqi <= 100) return 'Moderate';
        if (aqi <= 150) return 'Unhealthy for Sensitive Groups';
        if (aqi <= 200) return 'Unhealthy';
        if (aqi <= 300) return 'Very Unhealthy';
        return 'Hazardous';
    }
    
    function aqColor(aqi) {
        if (aqi <= 50) return '#00e400';
        if (aqi <= 100) return '#ffff00';
        if (aqi <= 150) return '#ff7e00';
        if (aqi <= 200) return '#ff0000';
        if (aqi <= 300) return '#8f3f97';
        return '#7e0023';
    }
    
    document.getElementById('aqOverlayToggle').addEventListener('change', function() {
        aqActive = this.checked;
        document.getElementById('aqLegend').style.display = this.checked ? 'flex' : 'none';
        if (this.checked) {
            if (!aqTileLayer) {
                aqTileLayer = L.tileLayer('/api/tiles/airquality/{z}/{x}/{y}.png', {
                    opacity: 0.6,
                    maxZoom: 14,
                    minZoom: 5,
                    attribution: 'AQI: Open-Meteo',
                    errorTileUrl: '',
                });
            }
            aqTileLayer.addTo(map);
        } else {
            if (aqTileLayer && map.hasLayer(aqTileLayer)) {
                map.removeLayer(aqTileLayer);
            }
        }
    });
    
    // Click to inspect AQI at a point
    map.on('click', async function(e) {
        if (!aqActive) return;
        const lat = e.latlng.lat.toFixed(2), lon = e.latlng.lng.toFixed(2);
        try {
            const res = await fetch(`/api/airquality?lat=${lat}&lon=${lon}`);
            const aq = await res.json();
            if (aq.error) return;
            const aqi = aq.us_aqi || 0;
            const label = aq.label || aqLabel(aqi);
            const color = aqColor(aqi);
            const parts = [];
            if (aq.pm2_5 != null) parts.push(`PM2.5: ${aq.pm2_5.toFixed(1)} µg/m³`);
            if (aq.pm10 != null) parts.push(`PM10: ${aq.pm10.toFixed(1)} µg/m³`);
            if (aq.ozone != null) parts.push(`O₃: ${aq.ozone.toFixed(1)} µg/m³`);
            L.popup()
                .setLatLng(e.latlng)
                .setContent(`<strong style="font-size:1.1em;color:${color}">AQI ${aqi} — ${label}</strong><br><small style="color:#555">${parts.join('<br>')}</small>`)
                .openOn(map);
        } catch(err) {}
    });

    document.getElementById('trailOverlayToggle').addEventListener('change', function() {
        if (this.checked) trailsOverlay.addTo(map);
        else if (map.hasLayer(trailsOverlay)) map.removeLayer(trailsOverlay);
    });
    
    document.getElementById('basemapSelect').addEventListener('change', function() {
        setBasemap(this.value);
    });
}

function clearMarkers() {
    if (markerCluster) markerCluster.clearLayers();
    markerMap.clear();
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
}

function onZoomChange() {
    const zoom = map.getZoom();
    routeLayers.forEach(l => {
        if (zoom >= 12) { if (!map.hasLayer(l)) map.addLayer(l); }
        else { if (map.hasLayer(l)) map.removeLayer(l); }
    });
}

function difficultyLabel(sac) {
    const m = {'hiking':'Easy','mountain_hiking':'Moderate','demanding_mountain_hiking':'Hard','alpine_hiking':'Expert','demanding_alpine_hiking':'Expert+','difficult_alpine_hiking':'Extreme'};
    return m[sac] || '';
}

function trailActivityIcons(activities) {
    if (!activities || !activities.length) return '';
    const icons = {
        hiking: '<svg class="activity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="Hiking"><circle cx="12" cy="4" r="2"/><path d="M7 21l3-9 2 3 2-3 3 9"/><path d="M10 12l-2-4h8l-2 4"/></svg>',
        biking: '<svg class="activity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="Biking"><circle cx="6" cy="17" r="3"/><circle cx="18" cy="17" r="3"/><path d="M6 17l3-7h4l2 3h3"/><circle cx="12" cy="7" r="1.5"/></svg>',
        horse: '<svg class="activity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="Horseback"><path d="M4 16c0-4 3-7 7-7h2l3-4 2 1-2 3h2c2 0 3 2 3 4v3h-2v2h-2v-2H8v2H6v-2H4v-3z"/><circle cx="16" cy="11" r="1" fill="currentColor"/></svg>',
    };
    return activities.map(a => icons[a] || '').join('');
}

function showView(view) {
    currentView = view;
    document.getElementById('mapView').style.display = view === 'map' ? 'block' : 'none';
    document.getElementById('mapOverlayControls').style.display = view === 'map' ? 'flex' : 'none';
    document.getElementById('listView').style.display = view === 'list' ? 'block' : 'none';
    document.getElementById('toggleMap').classList.toggle('active', view === 'map');
    document.getElementById('toggleList').classList.toggle('active', view === 'list');
    if (view === 'map' && map) setTimeout(() => map.invalidateSize(), 50);
}

document.getElementById('toggleMap').addEventListener('click', () => showView('map'));
document.getElementById('toggleList').addEventListener('click', () => showView('list'));

// --- Autocomplete ---
let acTimer = null;
const searchInput = document.getElementById('searchInput');
const acDropdown = document.getElementById('autocompleteDropdown');

searchInput.addEventListener('input', () => {
    clearTimeout(acTimer);
    const q = searchInput.value.trim();
    if (q.length < 2) { acDropdown.style.display = 'none'; return; }
    acTimer = setTimeout(() => fetchAutocomplete(q), 150);
});

searchInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') { acDropdown.style.display = 'none'; doSearch(); }
    if (e.key === 'Escape') acDropdown.style.display = 'none';
});

document.addEventListener('click', e => {
    if (!e.target.closest('.search-input-wrap')) acDropdown.style.display = 'none';
});

async function fetchAutocomplete(q) {
    try {
        const res = await fetch('/api/autocomplete?q=' + encodeURIComponent(q));
        const items = await res.json();
        if (!items.length) { acDropdown.style.display = 'none'; return; }
        
        acDropdown.innerHTML = items.map(item => {
            const icon = item.type === 'trail'
                ? '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 17l4-8 4 6 4-10 6 12"/></svg>'
                : '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0118 0z"/><circle cx="12" cy="10" r="3"/></svg>';
            const label = item.type === 'trail' ? 'Trail' : 'Area';
            return `<div class="ac-item" data-type="${item.type}" data-osm-type="${item.osm_type || ''}" data-osm-id="${item.osm_id || ''}" data-name="${item.name}" data-lat="${item.lat || ''}" data-lon="${item.lon || ''}">
                <span class="ac-icon">${icon}</span>
                <div class="ac-text">
                    <span class="ac-name">${item.name}</span>
                    ${item.context ? `<span class="ac-context">${item.context}</span>` : ''}
                </div>
                <span class="ac-label ac-label-${item.type}">${label}</span>
            </div>`;
        }).join('');
        acDropdown.style.display = 'block';
        
        acDropdown.querySelectorAll('.ac-item').forEach(el => {
            el.addEventListener('click', () => {
                acDropdown.style.display = 'none';
                const osmType = el.dataset.osmType;
                const osmId = el.dataset.osmId;
                if (el.dataset.type === 'trail' && (osmType === 'way' || osmType === 'relation') && osmId) {
                    window.location = `/trail/${osmType}/${osmId}`;
                } else {
                    // Area — fly to location immediately, then search
                    searchInput.value = el.dataset.name;
                    const acLat = parseFloat(el.dataset.lat);
                    const acLon = parseFloat(el.dataset.lon);
                    if (acLat && acLon) {
                        programmaticMove = true;
                        map.flyTo([acLat, acLon], 12, {duration: 1.2});
                    }
                    doSearch();
                }
            });
        });
    } catch(e) {
        acDropdown.style.display = 'none';
    }
}

// --- Search ---
async function doSearch() {
    const q = document.getElementById('searchInput').value;
    const state = document.getElementById('stateFilter').value;
    const params = new URLSearchParams();
    if (q) params.set('q', q);
    if (state) params.set('state', state);
    if (activeTrailType !== 'all') params.set('type', activeTrailType);
    
    document.getElementById('resultsList').innerHTML = '';
    showView('map');
    
    // Show loading in list view
    document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Searching trails via OpenStreetMap...</p></div>';
    
    try {
        const res = await fetch('/api/search?' + params);
        const data = await res.json();
        
        // Handle both formats: array (bbox/latlon) or object with center/bbox (text search)
        const trails = Array.isArray(data) ? data : (data.trails || []);
        const center = data.center;
        const geoBbox = data.bbox; // [south, north, west, east]
        
        if (data.error) {
            document.getElementById('resultsList').innerHTML = `<p class="muted">Error: ${data.error}</p>`;
            return;
        }
        if (!trails.length) {
            // Still fly to the searched location even if no trails found
            if (geoBbox) {
                programmaticMove = true;
                map.flyToBounds([[geoBbox[0], geoBbox[2]], [geoBbox[1], geoBbox[3]]], {padding: [50,50], maxZoom: 14, duration: 1.2});
            } else if (center) {
                programmaticMove = true;
                map.flyTo([center.lat, center.lon], 12, {duration: 1.2});
            }
            document.getElementById('resultsList').innerHTML = '<p class="muted">No trails found</p>';
            document.getElementById('resultCount').textContent = '0 trails found';
            return;
        }
        
        // Fly to searched location first, then render results
        if (geoBbox) {
            programmaticMove = true;
            map.flyToBounds([[geoBbox[0], geoBbox[2]], [geoBbox[1], geoBbox[3]]], {padding: [50,50], maxZoom: 14, duration: 1.2});
        } else if (center) {
            programmaticMove = true;
            map.flyTo([center.lat, center.lon], 12, {duration: 1.2});
        }
        
        currentTrails = trails;
        sessionStorage.setItem('trailcondish_results', JSON.stringify(trails));
        await renderResults(trails, !!(center || geoBbox)); // skip fitBounds if we already flew
    } catch(e) {
        document.getElementById('resultsList').innerHTML = `<p class="muted">Search failed: ${e.message}</p>`;
    }
}

// Condition colors for trail routes
const TRAIL_CONDITION_COLORS = {
    snowy: '#4a90d9',
    icy: '#8bb8e8',
    muddy: '#7f5539',
    wet: '#b08968',
    dry: '#2d6a4f',
    clear: '#2d6a4f',
};

let activeRouteLayer = null;
let routeConditionCache = {};

async function loadTrailRoute(trail) {
    // Remove previous active route
    if (activeRouteLayer) {
        map.removeLayer(activeRouteLayer);
        activeRouteLayer = null;
    }
    
    try {
        let trailApiUrl = `/api/trail/${trail.osm_type}/${trail.osm_id}`;
        if (trail.way_ids && trail.way_ids.length > 1) {
            trailApiUrl += `?way_ids=${trail.way_ids.join(',')}`;
        }
        const res = await fetch(trailApiUrl);
        const data = await res.json();
        if (!data.geometry || data.geometry.length < 2) return;
        
        // Get condition color — check weather
        let color = '#c44536'; // default red
        const condKey = `${trail.osm_type}:${trail.osm_id}`;
        
        if (routeConditionCache[condKey]) {
            color = routeConditionCache[condKey];
        } else if (data.lat && data.lon) {
            try {
                const wres = await fetch(`/api/weather/history?lat=${data.lat.toFixed(4)}&lon=${data.lon.toFixed(4)}`);
                const wdata = await wres.json();
                if (wdata.inference) {
                    color = TRAIL_CONDITION_COLORS[wdata.inference.condition] || '#2d6a4f';
                    routeConditionCache[condKey] = color;
                }
            } catch(e) {}
        }
        
        const latlngs = data.geometry.map(p => [p.lat, p.lon]);
        
        // Draw with casing for visibility
        const casing = L.polyline(latlngs, {color: '#fff', weight: 7, opacity: 0.6});
        const line = L.polyline(latlngs, {color: color, weight: 4, opacity: 0.9});
        activeRouteLayer = L.layerGroup([casing, line]).addTo(map);
        
        // Build condition label
        let condLabel = '';
        if (routeConditionCache[condKey]) {
            const cond = Object.keys(TRAIL_CONDITION_COLORS).find(k => TRAIL_CONDITION_COLORS[k] === color) || 'unknown';
            condLabel = `<br><span style="color:${color}; font-weight:700;">${cond.charAt(0).toUpperCase() + cond.slice(1)}</span>`;
        }
        
        // Update popup
        let trailUrl = `/trail/${trail.osm_type}/${trail.osm_id}`;
        if (trail.way_ids && trail.way_ids.length > 1) {
            trailUrl += `?way_ids=${trail.way_ids.join(',')}`;
        }
        const diff = difficultyLabel(trail.difficulty);
        const dist = data.distance_km ? `${data.distance_km} km` : '';
        L.popup()
            .setLatLng(latlngs[Math.floor(latlngs.length / 2)])
            .setContent(`<b>${trail.name}</b>${condLabel}<br>${diff ? diff + ' · ' : ''}${dist}<br><a href="${trailUrl}">View Trail →</a>`)
            .openOn(map);
        
        map.fitBounds(L.latLngBounds(latlngs), {padding: [40, 40]});
    } catch(e) {
        console.error('Failed to load trail route:', e);
    }
}

async function renderResults(trails, skipFitBounds) {
    clearMarkers();
    const bounds = [];
    
    document.getElementById('resultCount').textContent = `${trails.length} trail${trails.length !== 1 ? 's' : ''} found — loading conditions...`;
    
    // Build list HTML
    let html = '';
    trails.forEach(t => {
        const diff = difficultyLabel(t.difficulty);
        let trailUrl = `/trail/${t.osm_type}/${t.osm_id}`;
        if (t.way_ids && t.way_ids.length > 1) trailUrl += `?way_ids=${t.way_ids.join(',')}`;
        
        const actIcons = trailActivityIcons(t.activities || []);
        const lengthTag = t.length_miles ? `<span class="tag">${t.length_miles} mi</span>` : '';
        
        const condKey = (t.lat && t.lon) ? condCacheKey(t.lat, t.lon) : '';
        const cachedCond = condKey ? conditionCache[condKey] : null;
        const pinCond = cachedCond ? cachedCond.condition : 'clear';
        const pinSrc = `/static/pins/cond-${pinCond === 'dry' ? 'clear' : pinCond}.svg`;
        const trailId = `${t.osm_type}:${t.osm_id}`;
        
        html += `<div class="trail-card" data-trail-id="${trailId}" onclick="window.location='${trailUrl}'">
            <img class="tc-pin" src="${pinSrc}" alt="${pinCond}" data-lat="${t.lat || ''}" data-lon="${t.lon || ''}">
            <div class="tc-content">
                <h3 class="tc-name">${t.name}</h3>
                <div class="tc-tags">
                    ${diff ? `<span class="tag tag-diff">${diff}</span>` : ''}
                    ${lengthTag}
                    ${t.surface ? `<span class="tag">${t.surface}</span>` : ''}
                    ${t.distance && !t.length_miles ? `<span class="tag">${t.distance}</span>` : ''}
                    ${actIcons}
                </div>
                ${t.desc ? `<p class="tc-desc">${t.desc}</p>` : ''}
                <a href="${trailUrl}" class="tc-link">View Trail →</a>
            </div>
        </div>`;
        
        if (t.lat && t.lon) {
            // Use cached condition icon if available, otherwise default
            const cached = conditionCache[condCacheKey(t.lat, t.lon)];
            const icon = cached ? getConditionIcon(cached.condition) : defaultIcon;
            
            // Show condition in initial popup if cached, otherwise show loading
            let popupHtml;
            if (cached) {
                const condLabel = cached.condition.charAt(0).toUpperCase() + cached.condition.slice(1);
                const condColors = {clear:'#2d6a4f',dry:'#2d6a4f',wet:'#b08968',muddy:'#7f5539',snowy:'#4a90d9',icy:'#c44536'};
                const reasons = (cached.reasons || []).slice(0, 2).join('<br>');
                popupHtml = `<b>${t.name}</b><br><span style="color:${condColors[cached.condition] || '#2d6a4f'};font-weight:700">${condLabel}</span><br><small style="color:#666">${reasons}</small><br>${diff ? diff + '<br>' : ''}<a href="${trailUrl}">View Trail</a><br><small style="color:#888">Click pin to show route</small>`;
            } else {
                popupHtml = `<b>${t.name}</b><br><small style="color:#888">Loading conditions...</small><br>${diff ? diff + '<br>' : ''}<a href="${trailUrl}">View Trail</a><br><small style="color:#888">Click pin to show route</small>`;
            }
            const m = L.marker([t.lat, t.lon], {icon: icon})
                .bindPopup(popupHtml);
            m._trailData = t;
            m._trailCondition = cached ? cached.condition : 'clear';
            m.on('click', function() {
                loadTrailRoute(this._trailData);
            });
            markerMap.set(`${t.osm_type}:${t.osm_id}`, m);
            bounds.push([t.lat, t.lon]);
        }
    });
    
    document.getElementById('resultsList').innerHTML = html;
    if (bounds.length && !skipFitBounds) {
        programmaticMove = true;
        map.fitBounds(bounds, {padding: [30, 30]});
    }
    
    // Fetch conditions BEFORE showing pins — no icon flash
    await updateMarkerConditions(trails);
    
    // Now update all marker icons with the fetched conditions before adding to map
    for (const t of trails.filter(t => t.lat && t.lon)) {
        const cached = conditionCache[condCacheKey(t.lat, t.lon)];
        if (cached) {
            const mKey = `${t.osm_type}:${t.osm_id}`;
            const marker = markerMap.get(mKey);
            if (marker) {
                marker.setIcon(getConditionIcon(cached.condition));
                marker._trailCondition = cached.condition;
                // Update popup with real condition
                const condLabel = cached.condition.charAt(0).toUpperCase() + cached.condition.slice(1);
                const condColors = {clear:'#2d6a4f',dry:'#2d6a4f',wet:'#b08968',muddy:'#7f5539',snowy:'#4a90d9',icy:'#c44536'};
                const reasons = (cached.reasons || []).slice(0, 2).join('<br>');
                let trailUrl = `/trail/${t.osm_type}/${t.osm_id}`;
                if (t.way_ids && t.way_ids.length > 1) trailUrl += `?way_ids=${t.way_ids.join(',')}`;
                const diff = difficultyLabel(t.difficulty);
                marker.setPopupContent(
                    `<b>${t.name}</b><br>` +
                    `<span style="color:${condColors[cached.condition] || '#2d6a4f'};font-weight:700">${condLabel}</span><br>` +
                    `<small style="color:#666">${reasons}</small><br>` +
                    `${diff ? diff + '<br>' : ''}` +
                    `<a href="${trailUrl}">View Trail</a><br>` +
                    `<small style="color:#888">Click pin to show route</small>`
                );
            }
        }
    }
    
    // Batch-add all markers to cluster at once (with correct icons already set)
    const allMarkers = [];
    markerMap.forEach(m => allMarkers.push(m));
    markerCluster.addLayers(allMarkers);
    
    document.getElementById('resultCount').textContent = `${trails.length} trail${trails.length !== 1 ? 's' : ''} found`;
    
    // Route loading disabled to avoid Overpass rate limits
    // Routes are visible on the Waymarked Trails overlay instead
}

async function loadRoutes(trails) {
    // Load geometry for first 30 trails for route display
    const toLoad = trails.filter(t => t.lat && t.lon).slice(0, 30);
    for (const t of toLoad) {
        try {
            let routeUrl = `/api/trail/${t.osm_type}/${t.osm_id}`;
            if (t.way_ids && t.way_ids.length > 1) routeUrl += `?way_ids=${t.way_ids.join(',')}`;
            const res = await fetch(routeUrl);
            const data = await res.json();
            if (data.geometry && data.geometry.length > 1) {
                const latlngs = data.geometry.map(p => [p.lat, p.lon]);
                const line = L.polyline(latlngs, {color: '#2d6a4f', weight: 3, opacity: 0.7});
                routeLayers.push(line);
                // Only show if zoomed in enough
                if (map.getZoom() >= 12) line.addTo(map);
            }
        } catch(e) {}
    }
}

// Init map on page load
initMap();
document.getElementById('viewToggle').style.display = 'flex';

// Save map state on move
map.on('moveend', () => {
    const c = map.getCenter();
    sessionStorage.setItem('trailcondish_map', JSON.stringify({lat: c.lat, lng: c.lng, zoom: map.getZoom()}));
});

// Restore search results first (without fitting bounds)
const savedResults = sessionStorage.getItem('trailcondish_results');
if (savedResults) {
    try {
        const trails = JSON.parse(savedResults);
        if (trails.length) {
            currentTrails = trails;
            renderResults(trails, true); // skip fitBounds
        }
    } catch(e) {}
}

// Then restore map position (takes priority over fitBounds)
const savedMap = sessionStorage.getItem('trailcondish_map');
if (savedMap) {
    try {
        const s = JSON.parse(savedMap);
        map.setView([s.lat, s.lng], s.zoom);
    } catch(e) {}
}

// Show "Search This Area" button only after USER pans/zooms (not programmatic)
const searchMapBtn = document.getElementById('searchMapBtn');
map.on('moveend', () => {
    if (programmaticMove) {
        programmaticMove = false;
        searchMapBtn.style.display = 'none';
        return;
    }
    if (map.getZoom() >= 9) {
        searchMapBtn.style.display = 'flex';
    } else {
        searchMapBtn.style.display = 'none';
    }
});

searchMapBtn.addEventListener('click', async () => {
    const bounds = map.getBounds();
    const bbox = `${bounds.getSouth().toFixed(5)},${bounds.getWest().toFixed(5)},${bounds.getNorth().toFixed(5)},${bounds.getEast().toFixed(5)}`;
    searchMapBtn.style.display = 'none';
    searchMapBtn.innerHTML = '<div class="spinner-small"></div> Searching...';
    document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Searching this area...</p></div>';
    
    try {
        const typeParam = activeTrailType !== 'all' ? `&type=${activeTrailType}` : '';
        const res = await fetch(`/api/search?bbox=${encodeURIComponent(bbox)}${typeParam}`);
        const trails = await res.json();
        if (!trails.length) {
            document.getElementById('resultsList').innerHTML = '<p class="muted">No trails found in this area. Try zooming out.</p>';
            document.getElementById('resultCount').textContent = '0 trails found';
            return;
        }
        currentTrails = trails;
        sessionStorage.setItem('trailcondish_results', JSON.stringify(trails));
        renderResults(trails, true); // skip fitBounds — keep current view
    } catch(e) {
        document.getElementById('resultsList').innerHTML = `<p class="muted">Error: ${e.message}</p>`;
    } finally {
        searchMapBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg> Search This Area`;
    }
});

document.getElementById('searchBtn').addEventListener('click', doSearch);

document.getElementById('nearMeBtn').addEventListener('click', () => {
    if (!navigator.geolocation) return alert('Geolocation not supported');
    document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Getting your location...</p></div>';
    showView('map');
    
    navigator.geolocation.getCurrentPosition(async pos => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        searchInput.value = `Near ${lat.toFixed(2)}, ${lon.toFixed(2)}`;
        document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Searching nearby trails...</p></div>';
        
        try {
            const res = await fetch(`/api/search?lat=${lat}&lon=${lon}`);
            const trails = await res.json();
            if (!trails.length) {
                document.getElementById('resultsList').innerHTML = '<p class="muted">No trails found nearby</p>';
                document.getElementById('resultCount').textContent = '0 trails found';
                return;
            }
            currentTrails = trails;
            renderResults(trails);
        } catch(e) {
            document.getElementById('resultsList').innerHTML = `<p class="muted">Error: ${e.message}</p>`;
        }
    }, () => alert('Could not get location'));
});
</script>
{% endblock %}
