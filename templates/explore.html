{% extends "base.html" %}
{% block title %}Find Trails — Trail Condish{% endblock %}
{% block content %}
<section class="explore-header">
    <div class="container">
        <h1>Find Trails</h1>
        <div class="search-bar">
            <div class="search-input-wrap">
                <input type="text" id="searchInput" placeholder="Search trails or areas..." autocomplete="off">
                <div id="autocompleteDropdown" class="ac-dropdown"></div>
            </div>
            <select id="stateFilter">
                <option value="">All States</option>
            </select>
            <button id="nearMeBtn" class="btn btn-secondary" title="Near Me">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 2a10 10 0 0110 10 10 10 0 01-10 10A10 10 0 012 12 10 10 0 0112 2z" opacity=".3"/><path d="M12 8v0m0 8v0m-4-4h0m8 0h0"/></svg>
                Near Me
            </button>
            <button id="searchBtn" class="btn btn-primary">Search</button>
        </div>
        <div class="trail-filters">
            <span class="filter-label">Trail Type:</span>
            <button class="filter-chip active" data-filter="all">All</button>
            <button class="filter-chip" data-filter="hiking">Hiking</button>
            <button class="filter-chip" data-filter="biking">Biking</button>
            <button class="filter-chip" data-filter="paved">Paved / Path</button>
            <button class="filter-chip" data-filter="horse">Horseback</button>
        </div>
    </div>
</section>
<section class="explore-body">
    <div class="container">
        <div id="viewToggle" class="view-toggle" style="display:none;">
            <button id="toggleMap" class="toggle-btn active">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"/><line x1="8" y1="2" x2="8" y2="18"/><line x1="16" y1="6" x2="16" y2="22"/></svg>
                Map
            </button>
            <button id="toggleList" class="toggle-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
                List
            </button>
            <span id="resultCount" class="result-count"></span>
        </div>
        <div id="mapOverlayControls" class="map-overlay-controls">
            <label class="map-toggle">
                <select id="basemapSelect" class="basemap-select">
                    <option value="carto">Standard</option>
                    <option value="topo">Topographic</option>
                    <option value="satellite">Satellite</option>
                    <option value="terrain">Terrain</option>
                </select>
            </label>
            <label class="map-toggle"><input type="checkbox" id="conditionsOverlayToggle"> Projected Trail Conditions</label>
            <label class="map-toggle"><input type="checkbox" id="trailOverlayToggle"> Trail Routes</label>
            <div id="conditionsLegend" class="conditions-legend" style="display:none;">
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(45,106,79,0.3)"></span>Dry</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(176,137,104,0.5)"></span>Wet</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(127,85,57,0.6)"></span>Muddy</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(74,144,217,0.6)"></span>Snowy</span>
                <span class="legend-item"><span class="legend-swatch" style="background:rgba(196,69,54,0.6)"></span>Icy</span>
            </div>
        </div>
        <div id="mapView" class="map-view">
            <div id="map" class="explore-map-full"></div>
            <button id="searchMapBtn" class="btn-search-map" style="display:none;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="7"/><path d="M21 21l-4.35-4.35"/></svg>
                Search This Area
            </button>
        </div>
        <div id="listView" class="list-view" style="display:none;">
            <div id="resultsList" class="results-list"></div>
        </div>
    </div>
</section>
{% endblock %}
{% block scripts %}
<script>
const US_STATES = {"AL":"Alabama","AK":"Alaska","AZ":"Arizona","AR":"Arkansas","CA":"California","CO":"Colorado","CT":"Connecticut","DE":"Delaware","FL":"Florida","GA":"Georgia","HI":"Hawaii","ID":"Idaho","IL":"Illinois","IN":"Indiana","IA":"Iowa","KS":"Kansas","KY":"Kentucky","LA":"Louisiana","ME":"Maine","MD":"Maryland","MA":"Massachusetts","MI":"Michigan","MN":"Minnesota","MS":"Mississippi","MO":"Missouri","MT":"Montana","NE":"Nebraska","NV":"Nevada","NH":"New Hampshire","NJ":"New Jersey","NM":"New Mexico","NY":"New York","NC":"North Carolina","ND":"North Dakota","OH":"Ohio","OK":"Oklahoma","OR":"Oregon","PA":"Pennsylvania","RI":"Rhode Island","SC":"South Carolina","SD":"South Dakota","TN":"Tennessee","TX":"Texas","UT":"Utah","VT":"Vermont","VA":"Virginia","WA":"Washington","WV":"West Virginia","WI":"Wisconsin","WY":"Wyoming"};
const sel = document.getElementById('stateFilter');
Object.keys(US_STATES).sort().forEach(s => { const o = document.createElement('option'); o.value = s; o.textContent = s; sel.appendChild(o); });

let map, markerCluster, routeLayers = [];
let currentView = 'map'; // default to map
let currentTrails = [];
let activeTrailType = 'all';
let programmaticMove = false; // distinguish user pans from flyTo/fitBounds

// Condition pin icons
const conditionCache = {}; // key: "lat,lon" -> {condition, reasons}
const markerMap = new Map(); // key: trail osm_type:osm_id -> L.marker

function getConditionIcon(condition) {
    const iconMap = {
        'clear': '/static/pins/cond-clear.svg',
        'dry': '/static/pins/cond-clear.svg',
        'wet': '/static/pins/cond-wet.svg',
        'muddy': '/static/pins/cond-muddy.svg',
        'snowy': '/static/pins/cond-snowy.svg',
        'icy': '/static/pins/cond-icy.svg',
        'closed': '/static/pins/cond-closed.svg',
    };
    return L.icon({
        iconUrl: iconMap[condition] || iconMap['clear'],
        iconSize: [40, 50],
        iconAnchor: [20, 50],
        popupAnchor: [0, -50],
    });
}

const defaultIcon = getConditionIcon('clear');

function condCacheKey(lat, lon) {
    // Consistent key: round to 3 decimal places (~111m precision)
    return `${parseFloat(lat).toFixed(3)},${parseFloat(lon).toFixed(3)}`;
}

async function updateMarkerConditions(trails) {
    const withCoords = trails.filter(t => t.lat && t.lon);
    if (!withCoords.length) return;
    
    // Filter out already-cached trails
    const toFetch = withCoords.filter(t => !conditionCache[condCacheKey(t.lat, t.lon)]);
    
    if (toFetch.length > 0) {
        // Batch in groups of 20 (Open-Meteo multi-location limit)
        for (let i = 0; i < toFetch.length; i += 20) {
            const batch = toFetch.slice(i, i + 20);
            const lats = batch.map(t => parseFloat(t.lat).toFixed(4)).join(',');
            const lons = batch.map(t => parseFloat(t.lon).toFixed(4)).join(',');
            try {
                const res = await fetch(`/api/weather/grid?lats=${lats}&lons=${lons}`);
                const data = await res.json();
                if (Array.isArray(data)) {
                    for (let j = 0; j < batch.length; j++) {
                        conditionCache[condCacheKey(batch[j].lat, batch[j].lon)] = data[j] || {condition: 'clear', reasons: []};
                    }
                }
            } catch(e) { /* keep default icons on error */ }
        }
    }
    
    // Update all marker icons + condition tags from cache
    let changed = false;
    for (const t of withCoords) {
        const cached = conditionCache[condCacheKey(t.lat, t.lon)];
        if (cached) {
            const mKey = `${t.osm_type}:${t.osm_id}`;
            const marker = markerMap.get(mKey);
            if (marker && marker._trailCondition !== cached.condition) {
                marker.setIcon(getConditionIcon(cached.condition));
                marker._trailCondition = cached.condition;
                changed = true;
            }
        }
    }
    // Update condition pins in list view cards
    for (const t of withCoords) {
        const cached = conditionCache[condCacheKey(t.lat, t.lon)];
        if (cached) {
            const card = document.querySelector(`.trail-card[data-trail-id="${t.osm_type}:${t.osm_id}"] .tc-pin`);
            if (card) {
                const cond = cached.condition === 'dry' ? 'clear' : cached.condition;
                card.src = `/static/pins/cond-${cond}.svg`;
                card.alt = cached.condition;
            }
        }
    }
    
    // Rebuild clusters to pick up updated condition colors
    if (changed && markerCluster) {
        const allMarkers = [];
        markerMap.forEach(m => allMarkers.push(m));
        markerCluster.clearLayers();
        markerCluster.addLayers(allMarkers);
    }
}

// Trail type filter chips
document.querySelectorAll('.filter-chip').forEach(chip => {
    chip.addEventListener('click', function() {
        document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
        this.classList.add('active');
        activeTrailType = this.dataset.filter;
        // Re-search if we have results
        if (currentTrails.length > 0 || document.getElementById('searchInput').value.trim()) {
            doSearch();
        }
    });
});

const BASEMAPS = {
    carto: {url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', attr: '&copy; OSM &copy; CARTO', subdomains: 'abcd', maxZoom: 20},
    topo: {url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attr: '&copy; OSM &copy; OpenTopoMap', subdomains: 'abc', maxZoom: 17},
    satellite: {url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', attr: '&copy; Esri', maxZoom: 19},
    terrain: {url: 'https://{s}.tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey=6170aad10dfd42a38d4d8c709a536f38', attr: '&copy; Thunderforest &copy; OSM', subdomains: 'abc', maxZoom: 22},
};
let currentBasemap = null;

function setBasemap(key) {
    const cfg = BASEMAPS[key] || BASEMAPS.carto;
    if (currentBasemap) map.removeLayer(currentBasemap);
    currentBasemap = L.tileLayer(cfg.url, {attribution: cfg.attr, subdomains: cfg.subdomains || '', maxZoom: cfg.maxZoom || 20});
    currentBasemap.addTo(map);
    localStorage.setItem('tc_basemap', key);
}

function initMap() {
    if (map) return;
    map = L.map('map').setView([39.5, -98.5], 4);
    const saved = localStorage.getItem('tc_basemap') || 'carto';
    document.getElementById('basemapSelect').value = saved;
    setBasemap(saved);
    markerCluster = L.markerClusterGroup({
        maxClusterRadius: 50,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        chunkedLoading: true,
        iconCreateFunction: function(cluster) {
            const count = cluster.getChildCount();
            let size = count >= 50 ? 'large' : count >= 10 ? 'medium' : 'small';
            const dims = {small: [44, 54], medium: [52, 64], large: [60, 74]};
            const [w, h] = dims[size];
            const fs = {small: 13, medium: 15, large: 17}[size];
            
            // Determine dominant condition from child markers
            const condCounts = {};
            cluster.getAllChildMarkers().forEach(m => {
                const cond = m._trailCondition || 'clear';
                condCounts[cond] = (condCounts[cond] || 0) + 1;
            });
            let dominant = 'clear';
            let maxCount = 0;
            // Priority: icy > snowy > muddy > wet > clear/dry
            const priority = {icy: 50, snowy: 40, muddy: 30, wet: 20, clear: 0, dry: 0};
            for (const [cond, cnt] of Object.entries(condCounts)) {
                const score = cnt + (priority[cond] || 0) * 0.01;
                if (score > maxCount) { maxCount = score; dominant = cond; }
            }
            
            const colors = {
                clear: {pin: '#2d6a4f', inner: '#52b788'},
                dry: {pin: '#2d6a4f', inner: '#52b788'},
                wet: {pin: '#2d6a4f', inner: '#7b9ec4'},
                muddy: {pin: '#7f5539', inner: '#b08968'},
                snowy: {pin: '#4a90d9', inner: '#7bb8e8'},
                icy: {pin: '#c44536', inner: '#e07060'},
                closed: {pin: '#555', inner: '#888'},
            };
            const c = colors[dominant] || colors.clear;
            
            // SVG pin shape with count
            const svg = `<svg width="${w}" height="${h}" viewBox="0 0 44 54" xmlns="http://www.w3.org/2000/svg">
              <path d="M22,2 C33,2 42,11 42,22 C42,33 22,52 22,52 C22,52 2,33 2,22 C2,11 11,2 22,2Z" fill="${c.pin}" stroke="#f5f0e8" stroke-width="2"/>
              <circle cx="22" cy="20" r="13" fill="${c.inner}"/>
              <text x="22" y="25" text-anchor="middle" font-family="Nunito,sans-serif" font-weight="800" font-size="${fs}" fill="#fff">${count}</text>
            </svg>`;
            
            return L.divIcon({
                html: svg,
                className: 'cluster-pin',
                iconSize: L.point(w, h),
                iconAnchor: L.point(w/2, h),
            });
        }
    });
    map.addLayer(markerCluster);
    map.on('zoomend', onZoomChange);
    
    // Overlays
    const trailsOverlay = L.tileLayer('https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png', {opacity: 0.6, attribution:'Waymarked Trails'});
    let conditionsActive = false;
    let conditionsCache = {};
    let conditionsLoading = false;
    let canvasOverlay = null;
    let lastGrid = null;
    let lastGridBounds = null;
    
    // Condition severity for interpolation (0=dry, 1=wet, 2=muddy, 3=snowy, 4=icy)
    const COND_SCORE = {clear: 0, dry: 0, wet: 1, muddy: 2, snowy: 3, icy: 4};
    const COND_RGB = {
        0: [82, 183, 136],   // dry/clear - green
        1: [176, 137, 104],  // wet - tan
        2: [127, 85, 57],    // muddy - brown
        3: [74, 144, 217],   // snowy - blue
        4: [196, 69, 54],    // icy - red
    };
    
    function lerpColor(score) {
        const lo = Math.floor(Math.max(0, Math.min(3, score)));
        const hi = Math.min(4, lo + 1);
        const t = score - lo;
        const a = COND_RGB[lo], b = COND_RGB[hi];
        return [
            Math.round(a[0] + (b[0] - a[0]) * t),
            Math.round(a[1] + (b[1] - a[1]) * t),
            Math.round(a[2] + (b[2] - a[2]) * t),
        ];
    }
    
    async function loadConditionsGrid() {
        if (!conditionsActive || conditionsLoading) return;
        const zoom = map.getZoom();
        if (zoom < 5) {
            if (canvasOverlay) map.removeLayer(canvasOverlay);
            return;
        }
        
        conditionsLoading = true;
        try {
        const bounds = map.getBounds();
        const s = bounds.getSouth(), n = bounds.getNorth();
        const w = bounds.getWest(), e = bounds.getEast();
        
        // Fixed global grid spacing based on zoom level (deterministic)
        const gridSpacing = zoom >= 12 ? 0.03
                          : zoom >= 10 ? 0.06
                          : zoom >= 8  ? 0.15
                          : zoom >= 6  ? 0.4
                          :              0.8;
        
        // Snap bounds to world-fixed grid lines (+ 1 cell padding for smooth edges)
        const ps = Math.floor(s / gridSpacing) * gridSpacing - gridSpacing;
        const pn = Math.ceil(n / gridSpacing) * gridSpacing + gridSpacing;
        const pw = Math.floor(w / gridSpacing) * gridSpacing - gridSpacing;
        const pe = Math.ceil(e / gridSpacing) * gridSpacing + gridSpacing;
        
        // Build grid from world-fixed coordinates (always the same points regardless of pan)
        const grid = [];
        let r = 0;
        const precision = gridSpacing < 0.1 ? 4 : gridSpacing < 1 ? 2 : 1;
        for (let lat = ps; lat <= pn + gridSpacing * 0.01; lat += gridSpacing) {
            grid[r] = [];
            let c = 0;
            const snapLat = parseFloat((Math.round(lat / gridSpacing) * gridSpacing).toFixed(precision));
            for (let lon = pw; lon <= pe + gridSpacing * 0.01; lon += gridSpacing) {
                const snapLon = parseFloat((Math.round(lon / gridSpacing) * gridSpacing).toFixed(precision));
                const key = `${snapLat},${snapLon}`;
                grid[r][c] = {lat: snapLat, lon: snapLon, key, score: 0, reasons: []};
                c++;
            }
            r++;
        }
        const gridRows = grid.length;
        const gridCols = grid[0] ? grid[0].length : 0;
        
        if (gridRows < 2 || gridCols < 2) { conditionsLoading = false; return; }
        
        // Fetch weather for uncached points via batch endpoint
        const allPts = grid.flat();
        const uncached = allPts.filter(p => !conditionsCache[p.key]);
        if (uncached.length > 0) {
            try {
                const lats = uncached.map(p => p.lat.toFixed(4)).join(',');
                const lons = uncached.map(p => p.lon.toFixed(4)).join(',');
                const res = await fetch(`/api/weather/grid?lats=${lats}&lons=${lons}`);
                const data = await res.json();
                if (Array.isArray(data)) {
                    for (let i = 0; i < uncached.length; i++) {
                        conditionsCache[uncached[i].key] = data[i] || {condition: 'clear', reasons: []};
                    }
                }
            } catch(e) {
                for (const p of uncached) conditionsCache[p.key] = {condition: 'clear', reasons: []};
            }
        }
        
        // Assign scores from cache
        for (let r = 0; r < gridRows; r++) {
            for (let c = 0; c < gridCols; c++) {
                const inf = conditionsCache[grid[r][c].key] || {condition: 'clear'};
                grid[r][c].score = COND_SCORE[inf.condition] ?? 0;
                grid[r][c].reasons = inf.reasons || [];
            }
        }
        
        // Render interpolated canvas — high res for smooth gradients
        const canvasW = 600, canvasH = 400;
        const canvas = document.createElement('canvas');
        canvas.width = canvasW;
        canvas.height = canvasH;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(canvasW, canvasH);
        
        for (let py = 0; py < canvasH; py++) {
            for (let px = 0; px < canvasW; px++) {
                // Map pixel to grid position (float)
                const gr = (py / canvasH) * (gridRows - 1);
                const gc = (px / canvasW) * (gridCols - 1);
                
                // Bicubic-style smooth interpolation using Hermite smoothstep
                const r0 = Math.floor(gr), r1 = Math.min(gridRows - 1, r0 + 1);
                const c0 = Math.floor(gc), c1 = Math.min(gridCols - 1, c0 + 1);
                let tr = gr - r0, tc = gc - c0;
                // Smoothstep for less blocky transitions
                tr = tr * tr * (3 - 2 * tr);
                tc = tc * tc * (3 - 2 * tc);
                
                const s00 = grid[r0][c0].score;
                const s01 = grid[r0][c1].score;
                const s10 = grid[r1][c0].score;
                const s11 = grid[r1][c1].score;
                const score = s00 * (1 - tr) * (1 - tc) + s01 * (1 - tr) * tc + s10 * tr * (1 - tc) + s11 * tr * tc;
                
                const rgb = lerpColor(score);
                // Flip vertically (canvas y=0 is top, but lat increases upward)
                const fpy = canvasH - 1 - py;
                const fidx = (fpy * canvasW + px) * 4;
                imgData.data[fidx] = rgb[0];
                imgData.data[fidx + 1] = rgb[1];
                imgData.data[fidx + 2] = rgb[2];
                imgData.data[fidx + 3] = 80; // transparency
            }
        }
        ctx.putImageData(imgData, 0, 0);
        
        // Multi-pass blur for ultra-smooth gradients (no visible grid dots)
        const blurCanvas = document.createElement('canvas');
        blurCanvas.width = canvasW;
        blurCanvas.height = canvasH;
        const bCtx = blurCanvas.getContext('2d');
        bCtx.filter = 'blur(16px)';
        bCtx.drawImage(canvas, 0, 0);
        bCtx.filter = 'blur(8px)';
        bCtx.drawImage(blurCanvas, 0, 0);
        bCtx.filter = 'none';
        
        // Remove old overlay
        if (canvasOverlay) map.removeLayer(canvasOverlay);
        
        // Add as image overlay (use the blurred version)
        const imgUrl = blurCanvas.toDataURL();
        canvasOverlay = L.imageOverlay(imgUrl, [[ps, pw], [pn, pe]], {opacity: 0.5, interactive: false});
        canvasOverlay.addTo(map);
        
        lastGrid = grid;
        lastGridBounds = {s: ps, n: pn, w: pw, e: pe, rows: gridRows, cols: gridCols};
        } catch(err) { console.error('Conditions overlay error:', err); }
        conditionsLoading = false;
    }
    
    document.getElementById('conditionsOverlayToggle').addEventListener('change', function() {
        conditionsActive = this.checked;
        document.getElementById('conditionsLegend').style.display = this.checked ? 'flex' : 'none';
        if (this.checked) {
            loadConditionsGrid();
        } else {
            if (canvasOverlay) map.removeLayer(canvasOverlay);
        }
    });
    
    map.on('moveend', function() {
        if (conditionsActive) loadConditionsGrid();
    });
    
    // Click on map to see conditions at that point
    map.on('click', function(e) {
        if (!conditionsActive || !lastGrid || !lastGridBounds) return;
        const gb = lastGridBounds;
        const lat = e.latlng.lat, lon = e.latlng.lng;
        if (lat < gb.s || lat > gb.n || lon < gb.w || lon > gb.e) return;
        
        // Find nearest grid cell
        const gr = ((lat - gb.s) / (gb.n - gb.s)) * (gb.rows - 1);
        const gc = ((lon - gb.w) / (gb.e - gb.w)) * (gb.cols - 1);
        const r = Math.round(Math.max(0, Math.min(gb.rows - 1, gr)));
        const c = Math.round(Math.max(0, Math.min(gb.cols - 1, gc)));
        const cell = lastGrid[r] && lastGrid[r][c];
        if (!cell) return;
        const inf = conditionsCache[cell.key];
        if (!inf) return;
        
        const label = (inf.condition || 'clear').charAt(0).toUpperCase() + (inf.condition || 'clear').slice(1);
        const reasons = (inf.reasons || []).join('<br>');
        L.popup()
            .setLatLng(e.latlng)
            .setContent(`<strong style="font-size:1.1em">${label}</strong><br><small style="color:#555">${reasons}</small>`)
            .openOn(map);
    });
    
    document.getElementById('trailOverlayToggle').addEventListener('change', function() {
        if (this.checked) trailsOverlay.addTo(map);
        else if (map.hasLayer(trailsOverlay)) map.removeLayer(trailsOverlay);
    });
    
    document.getElementById('basemapSelect').addEventListener('change', function() {
        setBasemap(this.value);
    });
}

function clearMarkers() {
    if (markerCluster) markerCluster.clearLayers();
    markerMap.clear();
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
}

function onZoomChange() {
    const zoom = map.getZoom();
    routeLayers.forEach(l => {
        if (zoom >= 12) { if (!map.hasLayer(l)) map.addLayer(l); }
        else { if (map.hasLayer(l)) map.removeLayer(l); }
    });
}

function difficultyLabel(sac) {
    const m = {'hiking':'Easy','mountain_hiking':'Moderate','demanding_mountain_hiking':'Hard','alpine_hiking':'Expert','demanding_alpine_hiking':'Expert+','difficult_alpine_hiking':'Extreme'};
    return m[sac] || '';
}

function trailActivityIcons(activities) {
    if (!activities || !activities.length) return '';
    const icons = {
        hiking: '<svg class="activity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="Hiking"><circle cx="12" cy="4" r="2"/><path d="M7 21l3-9 2 3 2-3 3 9"/><path d="M10 12l-2-4h8l-2 4"/></svg>',
        biking: '<svg class="activity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="Biking"><circle cx="6" cy="17" r="3"/><circle cx="18" cy="17" r="3"/><path d="M6 17l3-7h4l2 3h3"/><circle cx="12" cy="7" r="1.5"/></svg>',
        horse: '<svg class="activity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="Horseback"><path d="M4 16c0-4 3-7 7-7h2l3-4 2 1-2 3h2c2 0 3 2 3 4v3h-2v2h-2v-2H8v2H6v-2H4v-3z"/><circle cx="16" cy="11" r="1" fill="currentColor"/></svg>',
    };
    return activities.map(a => icons[a] || '').join('');
}

function showView(view) {
    currentView = view;
    document.getElementById('mapView').style.display = view === 'map' ? 'block' : 'none';
    document.getElementById('mapOverlayControls').style.display = view === 'map' ? 'flex' : 'none';
    document.getElementById('listView').style.display = view === 'list' ? 'block' : 'none';
    document.getElementById('toggleMap').classList.toggle('active', view === 'map');
    document.getElementById('toggleList').classList.toggle('active', view === 'list');
    if (view === 'map' && map) setTimeout(() => map.invalidateSize(), 50);
}

document.getElementById('toggleMap').addEventListener('click', () => showView('map'));
document.getElementById('toggleList').addEventListener('click', () => showView('list'));

// --- Autocomplete ---
let acTimer = null;
const searchInput = document.getElementById('searchInput');
const acDropdown = document.getElementById('autocompleteDropdown');

searchInput.addEventListener('input', () => {
    clearTimeout(acTimer);
    const q = searchInput.value.trim();
    if (q.length < 2) { acDropdown.style.display = 'none'; return; }
    acTimer = setTimeout(() => fetchAutocomplete(q), 150);
});

searchInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') { acDropdown.style.display = 'none'; doSearch(); }
    if (e.key === 'Escape') acDropdown.style.display = 'none';
});

document.addEventListener('click', e => {
    if (!e.target.closest('.search-input-wrap')) acDropdown.style.display = 'none';
});

async function fetchAutocomplete(q) {
    try {
        const res = await fetch('/api/autocomplete?q=' + encodeURIComponent(q));
        const items = await res.json();
        if (!items.length) { acDropdown.style.display = 'none'; return; }
        
        acDropdown.innerHTML = items.map(item => {
            const icon = item.type === 'trail'
                ? '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 17l4-8 4 6 4-10 6 12"/></svg>'
                : '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0118 0z"/><circle cx="12" cy="10" r="3"/></svg>';
            const label = item.type === 'trail' ? 'Trail' : 'Area';
            return `<div class="ac-item" data-type="${item.type}" data-osm-type="${item.osm_type || ''}" data-osm-id="${item.osm_id || ''}" data-name="${item.name}" data-lat="${item.lat || ''}" data-lon="${item.lon || ''}">
                <span class="ac-icon">${icon}</span>
                <div class="ac-text">
                    <span class="ac-name">${item.name}</span>
                    ${item.context ? `<span class="ac-context">${item.context}</span>` : ''}
                </div>
                <span class="ac-label ac-label-${item.type}">${label}</span>
            </div>`;
        }).join('');
        acDropdown.style.display = 'block';
        
        acDropdown.querySelectorAll('.ac-item').forEach(el => {
            el.addEventListener('click', () => {
                acDropdown.style.display = 'none';
                const osmType = el.dataset.osmType;
                const osmId = el.dataset.osmId;
                if (el.dataset.type === 'trail' && (osmType === 'way' || osmType === 'relation') && osmId) {
                    window.location = `/trail/${osmType}/${osmId}`;
                } else {
                    // Area — fly to location immediately, then search
                    searchInput.value = el.dataset.name;
                    const acLat = parseFloat(el.dataset.lat);
                    const acLon = parseFloat(el.dataset.lon);
                    if (acLat && acLon) {
                        programmaticMove = true;
                        map.flyTo([acLat, acLon], 12, {duration: 1.2});
                    }
                    doSearch();
                }
            });
        });
    } catch(e) {
        acDropdown.style.display = 'none';
    }
}

// --- Search ---
async function doSearch() {
    const q = document.getElementById('searchInput').value;
    const state = document.getElementById('stateFilter').value;
    const params = new URLSearchParams();
    if (q) params.set('q', q);
    if (state) params.set('state', state);
    if (activeTrailType !== 'all') params.set('type', activeTrailType);
    
    document.getElementById('resultsList').innerHTML = '';
    showView('map');
    
    // Show loading in list view
    document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Searching trails via OpenStreetMap...</p></div>';
    
    try {
        const res = await fetch('/api/search?' + params);
        const data = await res.json();
        
        // Handle both formats: array (bbox/latlon) or object with center/bbox (text search)
        const trails = Array.isArray(data) ? data : (data.trails || []);
        const center = data.center;
        const geoBbox = data.bbox; // [south, north, west, east]
        
        if (data.error) {
            document.getElementById('resultsList').innerHTML = `<p class="muted">Error: ${data.error}</p>`;
            return;
        }
        if (!trails.length) {
            // Still fly to the searched location even if no trails found
            if (geoBbox) {
                programmaticMove = true;
                map.flyToBounds([[geoBbox[0], geoBbox[2]], [geoBbox[1], geoBbox[3]]], {padding: [50,50], maxZoom: 14, duration: 1.2});
            } else if (center) {
                programmaticMove = true;
                map.flyTo([center.lat, center.lon], 12, {duration: 1.2});
            }
            document.getElementById('resultsList').innerHTML = '<p class="muted">No trails found</p>';
            document.getElementById('resultCount').textContent = '0 trails found';
            return;
        }
        
        // Fly to searched location first, then render results
        if (geoBbox) {
            programmaticMove = true;
            map.flyToBounds([[geoBbox[0], geoBbox[2]], [geoBbox[1], geoBbox[3]]], {padding: [50,50], maxZoom: 14, duration: 1.2});
        } else if (center) {
            programmaticMove = true;
            map.flyTo([center.lat, center.lon], 12, {duration: 1.2});
        }
        
        currentTrails = trails;
        sessionStorage.setItem('trailcondish_results', JSON.stringify(trails));
        renderResults(trails, !!(center || geoBbox)); // skip fitBounds if we already flew
    } catch(e) {
        document.getElementById('resultsList').innerHTML = `<p class="muted">Search failed: ${e.message}</p>`;
    }
}

// Condition colors for trail routes
const TRAIL_CONDITION_COLORS = {
    snowy: '#4a90d9',
    icy: '#8bb8e8',
    muddy: '#7f5539',
    wet: '#b08968',
    dry: '#2d6a4f',
    clear: '#2d6a4f',
};

let activeRouteLayer = null;
let routeConditionCache = {};

async function loadTrailRoute(trail) {
    // Remove previous active route
    if (activeRouteLayer) {
        map.removeLayer(activeRouteLayer);
        activeRouteLayer = null;
    }
    
    try {
        let trailApiUrl = `/api/trail/${trail.osm_type}/${trail.osm_id}`;
        if (trail.way_ids && trail.way_ids.length > 1) {
            trailApiUrl += `?way_ids=${trail.way_ids.join(',')}`;
        }
        const res = await fetch(trailApiUrl);
        const data = await res.json();
        if (!data.geometry || data.geometry.length < 2) return;
        
        // Get condition color — check weather
        let color = '#c44536'; // default red
        const condKey = `${trail.osm_type}:${trail.osm_id}`;
        
        if (routeConditionCache[condKey]) {
            color = routeConditionCache[condKey];
        } else if (data.lat && data.lon) {
            try {
                const wres = await fetch(`/api/weather/history?lat=${data.lat.toFixed(4)}&lon=${data.lon.toFixed(4)}`);
                const wdata = await wres.json();
                if (wdata.inference) {
                    color = TRAIL_CONDITION_COLORS[wdata.inference.condition] || '#2d6a4f';
                    routeConditionCache[condKey] = color;
                }
            } catch(e) {}
        }
        
        const latlngs = data.geometry.map(p => [p.lat, p.lon]);
        
        // Draw with casing for visibility
        const casing = L.polyline(latlngs, {color: '#fff', weight: 7, opacity: 0.6});
        const line = L.polyline(latlngs, {color: color, weight: 4, opacity: 0.9});
        activeRouteLayer = L.layerGroup([casing, line]).addTo(map);
        
        // Build condition label
        let condLabel = '';
        if (routeConditionCache[condKey]) {
            const cond = Object.keys(TRAIL_CONDITION_COLORS).find(k => TRAIL_CONDITION_COLORS[k] === color) || 'unknown';
            condLabel = `<br><span style="color:${color}; font-weight:700;">${cond.charAt(0).toUpperCase() + cond.slice(1)}</span>`;
        }
        
        // Update popup
        let trailUrl = `/trail/${trail.osm_type}/${trail.osm_id}`;
        if (trail.way_ids && trail.way_ids.length > 1) {
            trailUrl += `?way_ids=${trail.way_ids.join(',')}`;
        }
        const diff = difficultyLabel(trail.difficulty);
        const dist = data.distance_km ? `${data.distance_km} km` : '';
        L.popup()
            .setLatLng(latlngs[Math.floor(latlngs.length / 2)])
            .setContent(`<b>${trail.name}</b>${condLabel}<br>${diff ? diff + ' · ' : ''}${dist}<br><a href="${trailUrl}">View Trail →</a>`)
            .openOn(map);
        
        map.fitBounds(L.latLngBounds(latlngs), {padding: [40, 40]});
    } catch(e) {
        console.error('Failed to load trail route:', e);
    }
}

function renderResults(trails, skipFitBounds) {
    clearMarkers();
    const bounds = [];
    
    document.getElementById('resultCount').textContent = `${trails.length} trail${trails.length !== 1 ? 's' : ''} found`;
    
    // Build list HTML
    let html = '';
    trails.forEach(t => {
        const diff = difficultyLabel(t.difficulty);
        let trailUrl = `/trail/${t.osm_type}/${t.osm_id}`;
        if (t.way_ids && t.way_ids.length > 1) trailUrl += `?way_ids=${t.way_ids.join(',')}`;
        
        const actIcons = trailActivityIcons(t.activities || []);
        const lengthTag = t.length_miles ? `<span class="tag">${t.length_miles} mi</span>` : '';
        
        const condKey = (t.lat && t.lon) ? condCacheKey(t.lat, t.lon) : '';
        const cachedCond = condKey ? conditionCache[condKey] : null;
        const pinCond = cachedCond ? cachedCond.condition : 'clear';
        const pinSrc = `/static/pins/cond-${pinCond === 'dry' ? 'clear' : pinCond}.svg`;
        const trailId = `${t.osm_type}:${t.osm_id}`;
        
        html += `<div class="trail-card" data-trail-id="${trailId}" onclick="window.location='${trailUrl}'">
            <img class="tc-pin" src="${pinSrc}" alt="${pinCond}" data-lat="${t.lat || ''}" data-lon="${t.lon || ''}">
            <div class="tc-content">
                <h3 class="tc-name">${t.name}</h3>
                <div class="tc-tags">
                    ${diff ? `<span class="tag tag-diff">${diff}</span>` : ''}
                    ${lengthTag}
                    ${t.surface ? `<span class="tag">${t.surface}</span>` : ''}
                    ${t.distance && !t.length_miles ? `<span class="tag">${t.distance}</span>` : ''}
                    ${actIcons}
                </div>
                ${t.desc ? `<p class="tc-desc">${t.desc}</p>` : ''}
                <a href="${trailUrl}" class="tc-link">View Trail →</a>
            </div>
        </div>`;
        
        if (t.lat && t.lon) {
            // Use cached condition icon if available, otherwise default
            const cached = conditionCache[condCacheKey(t.lat, t.lon)];
            const icon = cached ? getConditionIcon(cached.condition) : defaultIcon;
            
            const m = L.marker([t.lat, t.lon], {icon: icon})
                .bindPopup(`<b>${t.name}</b><br>${diff ? diff + '<br>' : ''}<a href="${trailUrl}">View Trail</a><br><small style="color:#888">Click pin to show route</small>`);
            m._trailData = t;
            m._trailCondition = cached ? cached.condition : 'clear';
            m.on('click', function() {
                loadTrailRoute(this._trailData);
            });
            markerMap.set(`${t.osm_type}:${t.osm_id}`, m);
            bounds.push([t.lat, t.lon]);
        }
    });
    
    // Batch-add all markers to cluster at once (much faster than one-by-one)
    const allMarkers = [];
    markerMap.forEach(m => allMarkers.push(m));
    markerCluster.addLayers(allMarkers);
    
    document.getElementById('resultsList').innerHTML = html;
    if (bounds.length && !skipFitBounds) {
        programmaticMove = true;
        map.fitBounds(bounds, {padding: [30, 30]});
    }
    
    // Fetch conditions and update pin icons (non-blocking)
    updateMarkerConditions(trails);
    
    // Route loading disabled to avoid Overpass rate limits
    // Routes are visible on the Waymarked Trails overlay instead
}

async function loadRoutes(trails) {
    // Load geometry for first 30 trails for route display
    const toLoad = trails.filter(t => t.lat && t.lon).slice(0, 30);
    for (const t of toLoad) {
        try {
            let routeUrl = `/api/trail/${t.osm_type}/${t.osm_id}`;
            if (t.way_ids && t.way_ids.length > 1) routeUrl += `?way_ids=${t.way_ids.join(',')}`;
            const res = await fetch(routeUrl);
            const data = await res.json();
            if (data.geometry && data.geometry.length > 1) {
                const latlngs = data.geometry.map(p => [p.lat, p.lon]);
                const line = L.polyline(latlngs, {color: '#2d6a4f', weight: 3, opacity: 0.7});
                routeLayers.push(line);
                // Only show if zoomed in enough
                if (map.getZoom() >= 12) line.addTo(map);
            }
        } catch(e) {}
    }
}

// Init map on page load
initMap();
document.getElementById('viewToggle').style.display = 'flex';

// Save map state on move
map.on('moveend', () => {
    const c = map.getCenter();
    sessionStorage.setItem('trailcondish_map', JSON.stringify({lat: c.lat, lng: c.lng, zoom: map.getZoom()}));
});

// Restore search results first (without fitting bounds)
const savedResults = sessionStorage.getItem('trailcondish_results');
if (savedResults) {
    try {
        const trails = JSON.parse(savedResults);
        if (trails.length) {
            currentTrails = trails;
            renderResults(trails, true); // skip fitBounds
        }
    } catch(e) {}
}

// Then restore map position (takes priority over fitBounds)
const savedMap = sessionStorage.getItem('trailcondish_map');
if (savedMap) {
    try {
        const s = JSON.parse(savedMap);
        map.setView([s.lat, s.lng], s.zoom);
    } catch(e) {}
}

// Show "Search This Area" button only after USER pans/zooms (not programmatic)
const searchMapBtn = document.getElementById('searchMapBtn');
map.on('moveend', () => {
    if (programmaticMove) {
        programmaticMove = false;
        searchMapBtn.style.display = 'none';
        return;
    }
    if (map.getZoom() >= 9) {
        searchMapBtn.style.display = 'flex';
    } else {
        searchMapBtn.style.display = 'none';
    }
});

searchMapBtn.addEventListener('click', async () => {
    const bounds = map.getBounds();
    const bbox = `${bounds.getSouth().toFixed(5)},${bounds.getWest().toFixed(5)},${bounds.getNorth().toFixed(5)},${bounds.getEast().toFixed(5)}`;
    searchMapBtn.style.display = 'none';
    searchMapBtn.innerHTML = '<div class="spinner-small"></div> Searching...';
    document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Searching this area...</p></div>';
    
    try {
        const typeParam = activeTrailType !== 'all' ? `&type=${activeTrailType}` : '';
        const res = await fetch(`/api/search?bbox=${encodeURIComponent(bbox)}${typeParam}`);
        const trails = await res.json();
        if (!trails.length) {
            document.getElementById('resultsList').innerHTML = '<p class="muted">No trails found in this area. Try zooming out.</p>';
            document.getElementById('resultCount').textContent = '0 trails found';
            return;
        }
        currentTrails = trails;
        sessionStorage.setItem('trailcondish_results', JSON.stringify(trails));
        renderResults(trails, true); // skip fitBounds — keep current view
    } catch(e) {
        document.getElementById('resultsList').innerHTML = `<p class="muted">Error: ${e.message}</p>`;
    } finally {
        searchMapBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg> Search This Area`;
    }
});

document.getElementById('searchBtn').addEventListener('click', doSearch);

document.getElementById('nearMeBtn').addEventListener('click', () => {
    if (!navigator.geolocation) return alert('Geolocation not supported');
    document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Getting your location...</p></div>';
    showView('map');
    
    navigator.geolocation.getCurrentPosition(async pos => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        searchInput.value = `Near ${lat.toFixed(2)}, ${lon.toFixed(2)}`;
        document.getElementById('resultsList').innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Searching nearby trails...</p></div>';
        
        try {
            const res = await fetch(`/api/search?lat=${lat}&lon=${lon}`);
            const trails = await res.json();
            if (!trails.length) {
                document.getElementById('resultsList').innerHTML = '<p class="muted">No trails found nearby</p>';
                document.getElementById('resultCount').textContent = '0 trails found';
                return;
            }
            currentTrails = trails;
            renderResults(trails);
        } catch(e) {
            document.getElementById('resultsList').innerHTML = `<p class="muted">Error: ${e.message}</p>`;
        }
    }, () => alert('Could not get location'));
});
</script>
{% endblock %}
